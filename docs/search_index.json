[["index.html", "Estadística Espacial con R Prólogo", " Estadística Espacial con R Rubén Fernández Casal (MODES, CITIC, UDC; ruben.fcasal@udc.es) Tomás Cotos Yáñez (SIDOR, UVIGO; cotos@uvigo.es) 2021-11-30 Prólogo La versión actual del libro se está desarrollando principalmente como apoyo a la docencia de la última parte de la asignatura de Análisis estadístico de datos con dependencia del Grado en Ciencia e Ingeniería de Datos de la UDC. El objetivo es que (futuras versiones del libro con contenidos adicionales) también resulte de utilidad para la docencia de la asignatura de Estadística Espacial del Máster interuniversitario en Técnicas Estadísticas). La teoría en este libro está basada en gran parte en la tesis doctoral: Fernández Casal, R. (2003). Geoestadística espacio-temporal: modelos flexibles de variogramas anisotrópicos no separables. Tesis doctoral, Universidad de Santiago de Compostela. donde se puede encontrar información adicional. Este libro ha sido escrito en R-Markdown empleando el paquete bookdown y está disponible en el repositorio Github: rubenfcasal/estadistica_espacial. Se puede acceder a la versión en línea a través del siguiente enlace: https://rubenfcasal.github.io/estadistica_espacial (también https://bit.ly/estadistica_espacial). donde puede descargarse en formato pdf. Para ejecutar los ejemplos mostrados en el libro sería necesario tener instalados los siguientes paquetes: sf, sp, starts, gstat, geoR, spacetime, sm, fields, rgdal, rgeos, maps, maptools, ggplot2, plot3D, lattice, classInt, viridis, dplyr, mapSpain, tmap, mapview, osmdata, rnaturalearth, ncdf, quadprog, spam, DEoptim. Por ejemplo mediante los siguientes comandos: pkgs &lt;- c(&quot;sf&quot;, &quot;sp&quot;, &quot;starts&quot;, &quot;gstat&quot;, &quot;geoR&quot;, &quot;spacetime&quot;, &quot;sm&quot;, &quot;fields&quot;, &quot;rgdal&quot;, &quot;rgeos&quot;, &quot;maps&quot;, &quot;maptools&quot;, &quot;ggplot2&quot;, &quot;plot3D&quot;, &quot;lattice&quot;, &quot;classInt&quot;, &quot;viridis&quot;, &quot;dplyr&quot;, &quot;mapSpain&quot;, &quot;tmap&quot;, &quot;mapview&quot;, &quot;osmdata&quot;, &quot;rnaturalearth&quot;, &quot;ncdf&quot;, &quot;quadprog&quot;, &quot;spam&quot;, &quot;DEoptim&quot; ) install.packages(setdiff(pkgs, installed.packages()[,&quot;Package&quot;]), dependencies = TRUE) Si aparecen errores (normalmente debidos a incompatibilidades con versiones ya instaladas), probar a ejecutar en lugar de lo anterior: install.packages(pkgs, dependencies=TRUE) # Instala todos... Además, para geoestadística no paramétrica se empleará el paquete npsp no disponible actualmente en CRAN (aunque esperamos que vuelva a estarlo pronto incluyendo soporte para el paquete sf). Se puede instalar la versión de desarrollo en GitHub, siguiendo las instrucciones de la web: # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;rubenfcasal/npsp&quot;) Aunque al necesitar compilación los usuarios de Windows deben tener instalado previamente la versión adecuada de Rtools, y Xcode los usuarios de OS X (para lo que se pueden seguir los pasos descritos aquí). Alternativamente, los usuarios de Windows (con una versión 4.X.X de R) pueden instalar este paquete ya compilado con el siguiente código: install.packages(&#39;https://github.com/rubenfcasal/npsp/releases/download/v0.7-8/npsp_0.7-8.zip&#39;, repos = NULL) Para generar el libro (compilar) serán necesarios paquetes adicionales, para lo que se recomendaría consultar el libro de Escritura de libros con bookdown en castellano. Este obra está bajo una licencia de Creative Commons Reconocimiento-NoComercial-SinObraDerivada 4.0 Internacional (esperamos poder liberarlo bajo una licencia menos restrictiva más adelante). "],["intro-estesp.html", "Capítulo 1 Introducción: Procesos espaciales y Geoestadística", " Capítulo 1 Introducción: Procesos espaciales y Geoestadística Es bien sabido que al utilizar en la práctica métodos estadísticos no siempre es adecuado suponer que las observaciones del fenómeno de interés han sido tomadas bajo condiciones idénticas e independientes unas de otras (i.e. que los datos son independientes e idénticamente distribuidos). Esta falta de homogeneidad en los datos suele ser modelada a través de la suposición de media no constante (por ejemplo suponiendo que ésta es una combinación lineal de ciertas variables explicativas) pero con la consideración de que los errores son independientes e idénticamente distribuidos. Sin embargo, esta suposición puede influir crucialmente en la inferencia (e.g. ver enlace), siendo en ocasiones preferible la suposición más realista de errores correlados. Frecuentemente los datos tienen una componente espacial y/o temporal asociada a ellos y es de esperar que datos cercanos en el espacio o en el tiempo sean más semejantes que aquellos que están más alejados; en cuyo caso no deben ser modelados como estadísticamente independientes, siendo más conveniente emplear modelos que exploten adecuadamente dicha componente espacial o espacio-temporal. De forma natural surge la hipótesis de que los datos cercanos en el espacio o en el tiempo están correlados y que la correlación disminuye al aumentar la separación entre ellos, por lo que se puede pensar en la presencia de una dependencia espacial o espacio-temporal. Esto da lugar al concepto de proceso espacial o espacio-temporal (Sección 1.1). La geoestadística (Sección 1.2) es una de las ramas de la estadística que se centra en el estudio de procesos de este tipo. La metodología espacial y espacio-temporal ha sido utilizada de forma creciente (especialmente durante los últimos 50 años) para resolver problemas en muchos campos. En muchos casos interesa analizar datos que tienen asociada una componente espacial o espacio-temporal de forma natural, por ejemplo, en campos relacionados con la geología, hidrología, ecología, ciencias medioambientales, meteorología, epidemiología, recursos mineros, geografía, astronomía, proceso de imágenes, experimentos agrícolas, etc. En estas disciplinas la metodología espacial puede ser de ayuda en alguna o en muchas etapas del estudio, desde el diseño inicial del muestreo hasta la representación final de los resultados obtenidos (p.e. para la generación de mapas o animaciones). "],["proc-esp.html", "1.1 Procesos espaciales", " 1.1 Procesos espaciales Supongamos que \\(Z(\\mathbf{s})\\) es un valor aleatorio en la posición espacial \\(\\mathbf{s} \\in \\mathbb{R}^{d}\\). Entonces, si \\(\\mathbf{s}\\) varía dentro del conjunto índice \\(D\\subset \\mathbb{R}^{d}\\) se obtiene el proceso espacial: \\[\\left\\{ Z(\\mathbf{s}) : \\mathbf{s} \\in D \\subset \\mathbb{R}^{d} \\right\\}\\] (también se suele denominar función aleatoria, campo espacial aleatorio o variable regionalizada). Una realización del proceso espacial se denotará por \\(\\left\\{ z(\\mathbf{s}) : \\mathbf{s} \\in D \\right\\}\\), pero normalmente solo se observará \\(\\{z(\\mathbf{s}_1), z(\\mathbf{s}_2), \\ldots, z(\\mathbf{s}_n)\\}\\), una realización parcial en \\(n\\) posiciones espaciales. Se suele distinguir entre distintos tipos de procesos espaciales dependiendo de las suposiciones acerca del dominio \\(D\\): Procesos geoestadísticos (índice espacial continuo): \\(D\\) es un subconjunto fijo que contiene un rectángulo \\(d\\)-dimensional de volumen positivo. El proceso puede ser observado de forma continua dentro del dominio. Un ejemplo claro sería la temperatura, aunque normalmente solo se dispone de datos en estaciones meteorológicas fijas, se podría observar en cualquier posición (y por tanto tiene sentido predecirla). Figura 1.1: Nivel del agua subterránea en 85 localizaciones del acuífero Wolfcamp (obtenidas durante un estudio sobre el posible emplazamiento de un depósito de residuos nucleares). Procesos reticulares/regionales (índice espacial discreto): \\(D\\) es un conjunto numerable de posiciones o regiones. El proceso solo puede ser observado en determinadas posiciones. Es habitual que los datos se correspondan con agregaciones (totales o valores medios) de una determinada zona (por ejemplo, países, provincias, ayuntamientos, zonas sanitarias). Son muy comunes en econometría o epidemiología. Figura 1.2: Porcentaje de incremento de las defunciones en el año 2020 respecto al 2019 por CCAA (datos provisionales INE). Procesos/patrones puntuales (índice espacial aleatorio): \\(D\\) es un proceso puntual en \\(\\mathbb{R}^{d}\\). Las posiciones en las que se observa el proceso son aleatorias. En muchas casos interesa únicamente la posición donde se observa el evento de interés (por ejemplo la posición en la que creció un árbol de una determinada especie). En el caso general, además de la posición se podría observar alguna otra característica (una marca; por ejemplo la altura o el diámetro del árbol), es lo que se conoce como proceso puntual marcado. Este tipo de datos son habituales en biología, ecología, criminología, etc. Figura 1.3: Mapa (de John Snow) del brote de cólera de 1854 en Londres. Nos centraremos en el caso de procesos geoestadísticos (también denominados procesos espaciales continuos). El caso de posiciones espaciales discretas se considerará como resultado de la discretización de un proceso continuo. Esto sería válido también para el caso espacio-temporal, por ejemplo podríamos considerar posiciones de la forma \\(\\mathbf{s}=(s_{1} , \\ldots,s_{d-1} ,t) \\in \\mathbb{R}^{d-1} \\times \\mathbb{R}^{+,0}\\), donde \\(\\mathbb{R}^{+,0} = \\left\\{ t \\in \\mathbb{R} : t \\geq 0 \\right\\}\\). Por tanto, las definiciones y métodos para procesos espaciales son en principio aplicables también al caso espacio-temporal. Sin embargo, la componente temporal presenta diferencias respecto a la componente espacial 1.1.1 Paquetes de R En R hay disponibles una gran cantidad de paquetes para el análisis estadístico de datos espaciales (ver por ejemplo CRAN Task View: Analysis of Spatial Data). Entre ellos podríamos destacar: Procesos geoestadísticos: gstat, geoR, geoRglm, fields, spBayes, RandomFields, VR:spatial, sgeostat, vardiag, npsp Procesos reticulares/regionales: spdep, DCluster, spgwr, ade4 Procesos puntuales: spatstat, VR:spatial, splancs Algunos de estos paquetes son la referencia para el análisis de este tipo de datos, aunque también están disponibles otros, como por ejemplo maptools, geosphere, tmap, mapsf, leaflet, mapview, mapdeck, ggmap, rgrass7, RSAGA, RPyGeo, RQGIS o r-arcgis, que implementan herramientas adicionales y permiten, por ejemplo, generar gráficos interactivos o interactuar con sistemas externos de información geográfica (GIS). En todos estos paquetes se trabajan con similares tipos de datos (espaciales y espacio-temporales) por lo que se han desarrollado paquetes que facilitan su manejo. Entre ellos destacan el paquete sp Bivand et al. (2013) y el paquete sf E. Pebesma y Bivand (2021). Otros paquetes para la manipulación de datos que pueden ser de interés son: raster, terra, starts, rgdal y rgeos, entre otros. En la Sección 2.1 se incluye información adicional sobre estos paquetes. En este libro emplearemos principalmente el paquete gstat para el análisis de datos geoestadísticos (aunque se incluye una introducción al paquete geoR en el Apéndice B) y el paquete sf para la manipulación de datos espaciales (en el Apéndice A se incluye una breve introducción a las clases sp para datos espaciales). References Bivand, R. S., Pebesma, E., y Gómez-Rubio, V. (2013). Applied Spatial Data Analysis with R (Second). Springer. http://www.asdar-book.org/ Pebesma, E., y Bivand, R. (2021). Spatial Data Science. https://keen-swartz-3146c4.netlify.app "],["geoestadistica.html", "1.2 Geoestadística", " 1.2 Geoestadística La geoestadística (Matheron 1962) surgió como una mezcla de varias disciplinas: ingeniería de minas, geología, matemáticas y estadística, para dar respuesta a problemas como, por ejemplo, el de la estimación de los recursos de una explotación minera (se desarrolló principalmente a partir de los años 80). La diferencia (ventaja) respecto a otras aproximaciones es que, además de tener en cuenta la tendencia espacial (variación de gran escala), también tiene en cuenta la correlación espacial (variación de pequeña escala). Otros métodos sin embargo, sólo incluyen la variación de larga escala y suponen que los errores son independientes (Sección 1.2.1). Hoy en día podemos decir que la geoestadística es la rama de la estadística espacial que estudia los procesos con índice espacial continuo. Uno de los problemas iniciales más importantes de la geoestadística fue la predicción de la riqueza de un bloque minero a partir de una muestra observada. A este proceso Matheron (1963) lo denominó kriging1, y también predicción espacial lineal óptima (estos métodos de predicción se muestran en el Capítulo 4). El modelo general habitualmente considerado en geoestadística considera que el proceso se descompone en variabilidad de gran escala y variabilidad de pequeña escala: \\[\\begin{equation} Z(\\mathbf{s}) = \\mu(\\mathbf{s}) + \\varepsilon(\\mathbf{s}), \\tag{1.1} \\end{equation}\\] donde: \\(\\mu(\\mathbf{s}) = E \\left( Z(\\mathbf{s}) \\right)\\) es la tendencia (función de regresión, determinística). \\(\\varepsilon(\\mathbf{s})\\) es un proceso de error de media cero que incorpora la dependencia espacial. Como en condiciones normales únicamente se dispone de una realización parcial del proceso, se suelen asumir hipótesis adicionales de estacionariedad sobre el proceso de error \\(\\varepsilon(\\mathbf{s})\\) para hacer posible la inferencia. En la Sección 1.3 se definen los principales tipos de estacionariedad habitualmente considerados en geoestadística y se introducen dos funciones relacionadas con procesos estacionarios, el covariograma y el variograma. Algunas propiedades de estas funciones, que podríamos decir que son las herramientas fundamentales de la geoestadística, se muestran en la Sección 2.2. 1.2.1 Modelos clásicos y modelos espaciales En general, cuando se considera que la componente espacial (o espacio-temporal) puede ser importante en el modelado y el análisis de los datos es necesaria una aproximación estadística distinta a la tradicionalmente usada. Uno de los modelos más utilizados en estadística para el caso de datos no homogéneos es el conocido modelo clásico de regresión lineal. Si \\(\\left\\{ Z(\\mathbf{s}):\\mathbf{s}\\in D\\subset \\mathbb{R}^{d} \\right\\}\\) es un proceso espacial, podemos suponer que: \\[Z(\\mathbf{s})=\\sum\\limits_{j=0}^{p}x_{j}(\\mathbf{s})\\beta_{j} +\\varepsilon(\\mathbf{s}),\\ \\mathbf{s}\\in D,\\] (un caso particular del modelo general (1.1)), donde \\(\\boldsymbol{\\beta }=(\\beta_{0}, \\ldots,\\beta_{p})^{\\top}\\in \\mathbb{R}^{p+1}\\) es un vector desconocido, \\(\\left\\{ x_{j} (\\cdot):j=0, \\ldots,p\\right\\}\\) un conjunto de variables explicativas (típicamente \\(x_0(\\cdot)=1\\)) y \\(\\varepsilon(\\cdot)\\) un proceso de media cero incorrelado (i.e. \\(Cov(\\varepsilon (\\mathbf{u}),\\varepsilon (\\mathbf{v}))=0\\) si \\(\\mathbf{u}\\neq \\mathbf{v}\\)) con \\(Var(\\varepsilon (\\mathbf{s}))=\\sigma^{2}\\). Supongamos por el momento que el objetivo es la estimación eficiente de la tendencia, o lo que es lo mismo la estimación óptima de los parámetros de la variación de gran escala \\(\\boldsymbol{\\beta}\\), a partir de los datos observados en un conjunto de posiciones espaciales \\(\\left\\{ \\mathbf{s}_{1}, \\ldots,\\mathbf{s}_{n} \\right\\}\\). Bajo las hipótesis anteriores: \\[\\mathbf{Z} = \\mathbf{X}\\boldsymbol{\\beta} + \\boldsymbol{\\varepsilon},\\] siendo \\(\\mathbf{Z}=\\left( Z(\\mathbf{s}_{1}), \\ldots,Z(\\mathbf{s}_{n}) \\right)^{\\top}\\), \\(\\mathbf{X}\\) una matriz \\(n\\times (p+1)\\) con \\(X_{ij}=x_{j-1}(\\mathbf{s}_{i})\\) y \\(\\boldsymbol{\\varepsilon} = \\left( \\varepsilon (\\mathbf{s}_{1}), \\ldots,\\varepsilon (\\mathbf{s}_{n})\\right)^{\\top}\\); y el estimador lineal insesgado de \\(\\boldsymbol{\\beta}\\) más eficiente resulta ser el estimador de mínimos cuadrados ordinarios (OLS, ordinary least squares): \\[\\begin{equation} \\hat{\\boldsymbol{\\beta}}_{ols}=(\\mathbf{X}^{\\top}\\mathbf{X})^{-1}\\mathbf{X}^{\\top}\\mathbf{Z}, \\tag{1.2} \\end{equation}\\] con \\[Var(\\hat{\\boldsymbol{\\beta}}_{ols})=\\sigma^{2}(\\mathbf{X}^{\\top}\\mathbf{X})^{-1}.\\] Sin embargo la suposición de que los errores son independientes e idénticamente distribuidos influye crucialmente en la inferencia. En el modelo anterior, en lugar de errores incorrelados, si suponemos que: \\[Var\\left( \\boldsymbol{\\varepsilon} \\right) =\\Sigma,\\] obtenemos el modelo lineal de regresión generalizado y en este caso el estimador lineal óptimo de \\(\\boldsymbol{\\beta}\\) es el estimador de mínimos cuadrados generalizados (GLS, generalized least squares): \\[\\begin{equation} \\hat{\\boldsymbol{\\beta}}_{gls} =(\\mathbf{X}^{\\top}\\Sigma^{-1} \\mathbf{X})^{-1} \\mathbf{X}^{\\top}\\Sigma^{-1} \\mathbf{Z}. \\tag{1.3} \\end{equation}\\] Si \\(\\Sigma=\\sigma^{2} \\mathbf{I}_{n}\\), siendo \\(\\mathbf{I}_{n}\\) la matriz identidad \\(n\\times n\\), los estimadores (1.2) y (1.3) coinciden; pero en caso contrario las estimaciones basadas en el modelo anterior pueden llegar a ser altamente ineficientes. Puede verse fácilmente que en el caso general: \\[Var\\left( \\hat{\\boldsymbol{\\beta}}_{gls} \\right)=(\\mathbf{X}^{\\top}\\Sigma^{-1} \\mathbf{X})^{-1}, \\\\ Var\\left( \\hat{\\boldsymbol{\\beta}}_{ols} \\right) =(\\mathbf{X}^{\\top}\\mathbf{X})^{-1} (\\mathbf{X}^{\\top}\\Sigma\\mathbf{X})(\\mathbf{X}^{\\top}\\mathbf{X})^{-1},\\] resultando además que \\(Var( \\hat{\\boldsymbol{\\beta}}_{ols}) - Var( \\hat{\\boldsymbol{\\beta}}_{gls} )\\) es una matriz semidefinida positiva (e.g. Searle, 1971, Sección 3.3). En muchos casos el objetivo final es la predicción del proceso en una posición espacial \\(\\mathbf{s}_{0}\\): \\[Z(\\mathbf{s}_{0} )=\\mathbf{x}^{\\top}\\boldsymbol{\\beta}+\\varepsilon (\\mathbf{s}_{0} ),\\] donde \\(\\mathbf{x}=\\left( x_{0} (\\mathbf{s}_{0} ), \\ldots,x_{p} (\\mathbf{s}_{0})\\right)^{\\top}\\). Bajo las hipótesis del modelo clásico el predictor óptimo sería la estimación de la tendencia \\(\\hat{\\mu}(\\mathbf{s}_{0} ) = \\mathbf{x}^{\\top}\\hat{\\boldsymbol{\\beta}}_{ols}\\) (el predictor óptimo de un error independiente sería cero). En el caso general, siguiendo esta aproximación, podríamos pensar en utilizar como predictor el estimador más eficiente de la tendencia: \\[\\hat{Z} (\\mathbf{s}_{0})=\\mathbf{x^{\\top}}\\hat{\\boldsymbol{\\beta}}_{gls},\\] sin embargo no es el predictor lineal óptimo. Puede verse (e.g. Goldberger, 1962; Sección 4.X) que en este caso el mejor predictor lineal insesgado es: \\[\\begin{equation} \\tilde{Z}(\\mathbf{s}_{0}) = \\mathbf{x}^{\\top}\\hat{\\boldsymbol{\\beta}}_{gls} + \\mathbf{c}^{\\top} \\Sigma^{-1} \\left( \\mathbf{Z} - \\mathbf{X}\\hat{\\boldsymbol{\\beta}}_{gls} \\right), \\tag{1.4} \\end{equation}\\] (el denominado predictor del kriging universal, Sección 4.X), siendo \\[\\mathbf{c} = \\left( Cov\\left( \\varepsilon (\\mathbf{s}_{1} ),\\varepsilon (\\mathbf{s}_{0} )\\right), \\ldots, Cov\\left( \\varepsilon (\\mathbf{s}_{n} ),\\varepsilon (\\mathbf{s}_{0} )\\right) \\right)^{\\top},\\] y la diferencia \\(Var( \\hat{Z} (\\mathbf{s}_{0} ) ) - Var( \\tilde{Z} (\\mathbf{s}_{0} ) ) \\ge 0\\) puede ser significativamente mayor que cero2 (si la dependencia espacial no es muy débil). Naturalmente, si se ignora por completo la dependencia y se emplea únicamente el estimador \\(\\hat{\\boldsymbol{\\beta}}_{ols}\\) disminuye aún más la eficiencia de las predicciones. Teniendo en cuenta los resultados anteriores podemos afirmar que al explotar la dependencia presente en los datos el incremento en eficiencia puede ser importante. Sin embargo el principal inconveniente es que en la práctica normalmente la matriz \\(\\Sigma\\) y el vector \\(\\mathbf{c}\\) son desconocidos. El procedimiento habitual, para evitar la estimación de \\(n+n(n+1)/2\\) parámetros adicionales a partir del conjunto de \\(n\\) observaciones, suele ser la elección de un modelo paramétrico adecuado: \\[C(\\mathbf{u},\\mathbf{v}\\left| \\boldsymbol{\\theta}\\right. )\\equiv Cov\\left( \\varepsilon (\\mathbf{u}),\\varepsilon (\\mathbf{v})\\right),\\] i.e. suponer que \\(\\Sigma \\equiv \\Sigma\\left( \\boldsymbol{\\theta}\\right)\\) y \\(\\mathbf{c}\\equiv \\mathbf{c}\\left( \\boldsymbol{\\theta}\\right)\\). Una hipótesis natural es suponer que los datos cercanos en el espacio o en el tiempo están correlados y que la correlación disminuye al aumentar la separación entre ellos; por tanto es normal pensar en errores espacialmente correlados. Por ejemplo, podemos considerar: \\[C(\\mathbf{u},\\mathbf{v}\\left| \\boldsymbol{\\theta}\\right. )=\\sigma^{2} \\rho^{\\left\\| \\mathbf{u}-\\mathbf{v}\\right\\| },\\] con \\(\\sigma^{2} \\geq 0\\) y \\(0&lt;\\rho &lt;1\\). De esta forma, si \\(\\hat{\\boldsymbol{\\theta}}\\) es un estimador de \\(\\boldsymbol{\\theta}\\), podemos obtener por ejemplo una aproximación del predictor óptimo de \\(Z(\\mathbf{s}_{0} )\\) sustituyendo en (1.4) \\(\\Sigma(\\boldsymbol{\\theta})\\) por \\(\\Sigma(\\hat{\\boldsymbol{\\theta}} )\\) y \\(\\mathbf{c}(\\boldsymbol{\\theta})\\) por \\(\\mathbf{c}(\\hat{\\boldsymbol{\\theta}} )\\). 1.2.2 Ventajas de la aproximación espacial (y espacio-temporal) Algunos de los beneficios de utilizar modelos espaciales para caracterizar y explotar la dependencia espacial de un conjunto de datos son los siguientes: Modelos más generales: en la mayoría de los casos, los modelos clásicos no espaciales son un caso particular de un modelo espacial. Estimaciones más eficientes: de la tendencia, de los efectos de variables explicativas, de promedios regionales Mejora de las predicciones: más eficientes, con propiedades de extrapolación más estables La variación espacial no explicada en la estructura de la media debe ser absorbida por la estructura del error, por lo que un modelo que incorpore la dependencia espacial puede decirse que esta protegido frente a una mala especificación de este tipo. Esto en muchos casos tiene como resultado una simplificación en la especificación de la tendencia; en general los modelos con dependencia espacial suelen tener una descripción más parsimoniosa (en ocasiones con muchos menos parámetros) que los clásicos modelos de superficie de tendencia. D. G. Krige fue un ingeniero de minas de Sudáfrica que desarrolló en los años 50 métodos empíricos para determinar la distribución de la riqueza de un mineral a partir de valores observados. Sin embargo la formulación de la predicción espacial lineal óptima no procede del trabajo de Krige. Al mismo tiempo que la geoestadística se desarrollaba en la ingeniería de minas por Matheron en Francia, la misma idea se desarrollaba en la meteorología por L.S. Gandin en la antigua Unión Soviética. El nombre que Gandin le dio a esta aproximación fue análisis objetivo y utilizó la terminología de interpolación óptima en lugar de kriging. Para más detalles sobre el origen del kriging ver p.e. Cressie (1990). Por ejemplo, para un caso particular, Goldberger (1962, pp.374-375) observó que la mejora en la predicción puede llegar a ser del 50%. En Cressie (1993, Sección 1.3) se muestran también otros ejemplos del efecto de la presencia de correlación en la estimación. "],["procesos-estacionarios.html", "1.3 Procesos espaciales estacionarios", " 1.3 Procesos espaciales estacionarios Supongamos que \\(\\left\\{ Z(\\mathbf{s}) : \\mathbf{s} \\in D \\subset \\mathbb{R}^{d} \\right\\}\\) es un proceso geoestadístico. Este proceso aleatorio se puede caracterizar a través de las funciones de distribución finito-dimensionales: \\[F_{\\mathbf{s}_1, \\ldots, \\mathbf{s}_m}(z_1, \\ldots, z_m) = P\\left(Z(\\mathbf{s}_1)\\leq z_1 , \\ldots,Z(\\mathbf{s}_m)\\leq z_m \\right)\\] (o de las funciones de densidad correspondientes \\(f_{\\mathbf{s}_1, \\ldots, \\mathbf{s}_m}(z_1, \\ldots, z_m)\\). Por ejemplo, el proceso se dice normal (o gaussiano) si para cada posible conjunto de \\(m \\in \\mathbb{N}\\) posiciones espaciales, \\(\\{\\mathbf{s}_1, \\ldots, \\mathbf{s}_m\\}\\), su función de distribución \\(F_{\\mathbf{s}_1, \\ldots, \\mathbf{s}_m}\\) es normal (gaussiana). Como ya se comentó en la Sección 1.1, en general no se puede disponer de una realización completa del proceso \\(Z(\\cdot)\\) y solamente se observan valores en unas posiciones espaciales conocidas \\(\\left\\{ \\mathbf{s}_1, \\ldots, \\mathbf{s}_{n} \\right\\}\\) (que por lo general van a ser irregulares). Por tanto es necesario hacer algunas suposiciones acerca del proceso de forma que sea posible la inferencia sobre el mismo. Lo habitual es asumir algún tipo de estacionariedad del proceso (o del proceso de error, suponiendo que el proceso no tiene media constante y sigue el modelo general (1.1)). El proceso \\(Z(\\cdot)\\) se dice estrictamente estacionario si al trasladar (en cualquier dirección) una configuración cualquiera de posiciones espaciales la distribución conjunta no varia: \\[F_{\\mathbf{s}_1 +\\mathbf{h}, \\ldots,\\mathbf{s}_m +\\mathbf{h}}(z_1, \\ldots, z_m) = F_{\\mathbf{s}_1, \\ldots, \\mathbf{s}_m}(z_1, \\ldots, z_m),\\ \\forall \\mathbf{h}\\in D,\\ \\forall m\\geq 1.\\] El proceso \\(Z(\\cdot)\\) se dice estacionario de segundo orden (también proceso estacionario homogéneo o débilmente estacionario) si tiene media constante y la covarianza entre dos posiciones depende únicamente del salto entre ellas: \\(E(Z(\\mathbf{s}))=\\mu,\\ \\forall \\mathbf{s}\\in D\\). \\(Cov(Z(\\mathbf{s}_1), Z(\\mathbf{s}_2)) = C(\\mathbf{s}_1 -\\mathbf{s}_2),\\ \\forall \\mathbf{s}_1 ,\\mathbf{s}_2 \\in D\\). La función \\(C(\\cdot)\\) se denomina covariograma (también autocovariograma o función de covarianzas). Si además \\(C(\\mathbf{h}) \\equiv C(\\left\\| \\mathbf{h}\\right\\|)\\) (sólo depende de la magnitud y no de la dirección del salto) se dice que el covariograma es isotrópico (en caso contrario se dice que es anisotrópico; 3.2.2). Si un proceso es estrictamente estacionario y \\(Var(Z(\\mathbf{s}))\\) es finita, entonces es estacionario de segundo orden. Además, como es bien conocido, en el caso de procesos normales ambas propiedades son equivalentes (ya que están caracterizados por su media y covarianza). En algunos casos en lugar del covariograma se utiliza el correlograma: \\[\\rho (\\mathbf{h}) = \\dfrac{C(\\mathbf{h})}{C(\\mathbf{0})} \\in \\left[-1,+1\\right],\\] suponiendo que \\(C(\\mathbf{0}) = Var(Z(\\mathbf{s})) &gt;0\\). Sin embargo lo habitual es modelar la dependencia espacial a través del variograma (principalmente por sus ventajas en la estimación; Sección 3.1), definido a continuación. Se dice que el proceso es intrínsecamente estacionario (también proceso espacial de incrementos estacionarios u homogéneos) si: \\(E(Z(\\mathbf{s}))=\\mu,\\ \\forall \\mathbf{s}\\in D\\). \\(Var(Z(\\mathbf{s}_1)-Z(\\mathbf{s}_2)) = 2\\gamma (\\mathbf{s}_1 - \\mathbf{s}_2),\\ \\forall \\mathbf{s}_1 ,\\mathbf{s}_2 \\in D\\). La función \\(2\\gamma (\\cdot)\\) se denomina variograma y \\(\\gamma (\\cdot)\\) semivariograma. Al igual que en el caso anterior, si además \\(\\gamma(\\mathbf{h}) \\equiv \\gamma(\\left\\| \\mathbf{h}\\right\\|)\\) (sólo depende de la distancia) se dice que el variograma es isotrópico. La clase de procesos intrínsecamente estacionarios es más general que la clase de procesos estacionarios de segundo orden. Si un proceso estacionario de segundo orden tiene covariograma \\(C(\\cdot)\\), como: \\[\\begin{aligned} Var(Z(\\mathbf{s}_1)-Z(\\mathbf{s}_2)) &amp;= Var(Z(\\mathbf{s}_1)) + Var(Z(\\mathbf{s}_2))-2Cov(Z(\\mathbf{s}_1),Z(\\mathbf{s}_2)) \\\\ &amp;=2\\left(C(\\mathbf{0})-C(\\mathbf{s}_1 -\\mathbf{s}_2)\\right), \\end{aligned}\\] entonces su semivariograma viene dado por: \\[\\gamma (\\mathbf{h}) = C(\\mathbf{0})-C(\\mathbf{h}),\\] y por tanto es un proceso intrínsecamente estacionario. El reciproco en general no es cierto (por ejemplo el caso de un movimiento browniano), aunque sí se verifica en muchos casos. Normalmente cuando no se verifica es debido a que el proceso no tiene media constante y puede ser modelado como una función de tendencia más un error estacionario de segundo orden (o cuando se consideran los errores del modelo general, la tendencia no está especificada correctamente). Si el variograma está acotado y: \\[\\lim \\limits_{\\left\\| \\mathbf{h}\\right\\| \\rightarrow \\infty }\\gamma(\\mathbf{h})=\\sigma^2,\\] entonces3 podemos obtener el covariograma correspondiente como: \\[C(\\mathbf{h})=\\sigma^2-\\gamma (\\mathbf{h}).\\] A \\(\\sigma^{2} = C(\\mathbf{0})\\) se le denomina umbral (o meseta) del semivariograma. La relación entre el semivariograma y el covariograma se ilustra en la Figura 1.4. Además del umbral, hay otras características geométricas del variograma (o del covariograma) de especial importancia4, entre ellas destacarían el efecto pepita (o nugget) y el rango (o alcance). La Figura 1.4 ilustra las distintas características del semivariograma. Figura 1.4: Relación entre el covariograma (línea discontinua) y el variograma (línea continua) en el caso unidimensional (o isotrópico), y principales características. Siempre se verifica que \\(\\gamma (\\mathbf{0})=0\\), sin embargo puede ser que: \\[\\lim \\limits_{\\mathbf{h}\\rightarrow \\mathbf{0}} \\gamma(\\mathbf{h}) = c_0 &gt; 0.\\] entonces \\(c_0\\) se denomina efecto pepita (o nugget)5. Además, si \\(\\sigma^{2}\\) es el umbral del semivariograma (suponiendo que existe), a \\(\\sigma ^{2} -c_0\\) se le denomina umbral parcial. Las propiedades de continuidad (y derivabilidad) del variograma (o el covariograma) en el origen están relacionadas con las propiedades de continuidad (y diferenciabilidad) en media cuadrática del proceso \\(Z(\\cdot)\\) (ver e.g. Chilès y Delfiner, 1999, Sección 2.3.1). Por ejemplo, el proceso es continuo en media cuadrática si y sólo si su variograma (covariograma) es continuo en el origen. Entonces la presencia de efecto nugget indica que (en teoría) el proceso no es continuo y por tanto altamente irregular. La proporción del efecto nugget en el umbral total \\(c_0 /\\sigma^{2}\\) proporciona mucha información acerca del grado de dependencia espacial presente en los datos. Por ejemplo, en el caso en que toda la variabilidad es efecto nugget (i.e. \\(\\gamma (\\mathbf{h})=c_0\\), \\(\\forall \\mathbf{h}\\neq \\mathbf{0}\\)) entonces \\(Z(\\mathbf{s}_1)\\) y \\(Z(\\mathbf{s}_2)\\) son incorrelados \\(\\forall \\mathbf{s}_1 ,\\mathbf{s}_2 \\in D\\) independientemente de lo cerca que estén (el proceso \\(Z(\\cdot)\\) es ruido blanco). Por tanto podemos pensar en \\(c_0 /\\sigma^{2}\\) como la proporción de variabilidad independiente, aunque en la práctica típicamente no se dispone de información sobre el variograma a distancias menores de \\(\\min \\left\\{ \\left\\| \\mathbf{s}_{i} -\\mathbf{s}_{j} \\right\\| :1\\leq i&lt;j\\leq n\\right\\}\\) (la estimación de \\(c_0\\) se obtiene normalmente extrapolando un variograma experimental cerca del origen). Si \\(\\sigma ^{2}\\) es el umbral del semivariograma (suponiendo que existe), se define el rango (o alcance) del semivariograma en la dirección \\(\\mathbf{e}_0 \\in \\mathbb{R}^{d}\\) con \\(\\left\\| \\mathbf{e}_0 \\right\\| = 1\\), como el mínimo salto en esa dirección en el que se alcanza el umbral: \\[a_0 =\\min \\left\\{ a:\\gamma (a\\left( 1+\\varepsilon \\right) \\mathbf{e}_0 )=\\sigma ^{2} , \\forall \\varepsilon &gt;0\\right\\}.\\] El rango en la dirección \\(\\mathbf{e}_0\\) puede interpretarse como el salto \\(h\\) a partir del cual no hay correlación entre \\(Z(\\mathbf{s})\\) y \\(Z(\\mathbf{s}\\pm h\\mathbf{e}_0)\\), por tanto está íntimamente ligado a la noción de zona de influencia (y tiene un papel importante en la determinación de criterios de vecindad). En los casos en los que el semivariograma alcanza el umbral asintóticamente (rango infinito), se suele considerar el rango práctico, definido como el mínimo salto en el que se alcanza el 95% del umbral. El variograma y el covariograma son las funciones habitualmente consideradas en geoestadística para el modelado de la dependencia espacial (o espacio-temporal), y son consideradas como un parámetro (de especial interés) del proceso. En la práctica normalmente se suele utilizar el variograma, no sólo porque es más general (puede existir en casos en que el covariograma no), sino por las ventajas en su estimación (Sección 3.1; Cressie, 1993, Sección 2.4.1). No obstante, en muchos casos los modelos de variograma se obtienen a partir de modelos de covariograma. 1.3.1 Propiedades elementales del covariograma y del variograma El variograma y el covariograma deben verificar ciertas propiedades que sus estimadores no siempre verifican, a continuación se detallan algunas de ellas. Si \\(Z(\\cdot)\\) es un proceso estacionario de segundo orden con covariograma \\(C(\\cdot)\\), entonces se verifica que \\(C(\\mathbf{0}) = Var( Z(\\mathbf{s}) ) \\geq 0\\), es una función par \\(C(\\mathbf{h})=C(-\\mathbf{h})\\), y por la desigualdad de Cauchy-Schwarz \\(\\left| C(\\mathbf{h})\\right| \\leq C(\\mathbf{0})\\). Además, el covariograma debe ser semidefinido positivo, es decir: \\[\\sum\\limits_{i=1}^{m} \\sum\\limits_{j=1}^{m} a_i a_j C(\\mathbf{s}_i-\\mathbf{s}_j) \\geq 0 \\\\ \\forall m\\geq 1,\\ \\forall \\mathbf{s}_i \\in D,\\ \\forall a_i \\in \\mathbb{R};\\ i=1, \\ldots,m,\\] ya que: \\[\\sum\\limits_{i=1}^{m}\\sum\\limits_{j=1}^{m}a_i a_j C(\\mathbf{s}_i -\\mathbf{s}_j) = Var\\left\\{\\sum\\limits_{i=1}^{m}a_i Z(\\mathbf{s}_i) \\right\\}\\] La condición es necesaria y suficiente para que exista un proceso estacionario de segundo orden con covariograma \\(C(\\cdot)\\) (se puede construir un proceso normal multivariante con covarianzas definidas por \\(C(\\cdot)\\)). Por tanto la clase de covariogramas válidos en \\(\\mathbb{R}^d\\) es equivalente a la clase de funciones semidefinidas positivas en \\(\\mathbb{R}^d\\). Algunas propiedades adicionales que verifican los covariogramas son las siguientes: Si \\(C(\\cdot)\\) es un covariograma válido en \\(\\mathbb{R}^d\\), entonces \\(aC(\\cdot)\\), \\(\\forall a\\geq 0\\), es también un covariograma válido en \\(\\mathbb{R}^d\\). Si \\(C_1 (\\cdot)\\) y \\(C_2 (\\cdot)\\) son covariogramas válidos en \\(\\mathbb{R}^d\\), entonces \\(C_1 (\\cdot) + C_2 (\\cdot)\\) es un covariograma válido en \\(\\mathbb{R}^d\\). Lo que equivale a suponer que el proceso \\(Z(\\cdot)\\) se obtiene como suma de dos procesos estacionarios de segundo orden independientes: \\(Z(\\mathbf{s})=Z_1 (\\mathbf{s})Z_2 (\\mathbf{s})\\), con covariogramas \\(C_1 (\\cdot)\\) y \\(C_2 (\\cdot)\\) respectivamente. Si \\(C_1 (\\cdot)\\) y \\(C_2 (\\cdot)\\) son covariogramas válidos en \\(\\mathbb{R}^d\\), entonces \\(C(\\cdot) = C_1 (\\cdot)C_2 (\\cdot)\\) es un covariograma válido en \\(\\mathbb{R}^d\\). Lo que equivale a suponer que el proceso se obtiene como producto de dos procesos estacionarios de segundo orden independientes. Un covariograma isotrópico válido en \\(\\mathbb{R}^d\\) es también un covariograma isotrópico válido en \\(\\mathbb{R}^m\\), \\(\\forall m\\leq d\\) (el recíproco no es en general cierto, ver p.e. Cressie, 1993, p. 84). Si \\(\\gamma (\\cdot)\\) es el semivariograma de un proceso intrínsecamente estacionario \\(Z(\\cdot)\\), entonces se verifica que \\(\\gamma (\\mathbf{0})=0\\), \\(\\gamma (\\mathbf{h})\\geq 0\\) y \\(\\gamma (\\mathbf{h})=\\gamma (-\\mathbf{h})\\). El semivariograma debe ser además condicionalmente semidefinido negativo, es decir: \\[\\sum\\limits_{i=1}^{m}\\sum\\limits_{j=1}^{m}a_i a_j \\gamma(\\mathbf{s}_i -\\mathbf{s}_j) \\leq 0 \\\\ \\forall m\\geq 1,\\forall \\mathbf{s}_i \\in D,\\forall a_i \\in \\mathbb{R};i=1, \\ldots,m,\\text{tales que } \\sum\\limits_{i=1}^{m}a_i = 0.\\] Esta condición es necesaria pero no suficiente (aunque pocas condiciones adicionales son necesarias para que el recíproco sea cierto; ver Cressie, 1993, Sección 3.5.2). Algunas propiedades adicionales que verifica un variograma son las siguientes: Si \\(\\gamma (\\cdot)\\) es un semivariograma válido en \\(\\mathbb{R}^d\\), entonces \\(a\\gamma (\\cdot)\\), \\(\\forall a\\geq 0\\), es también un semivariograma válido en \\(\\mathbb{R}^d\\). Si \\(\\gamma_1 (\\cdot)\\) y \\(\\gamma_2 (\\cdot)\\) son semivariogramas válidos en \\(\\mathbb{R}^d\\), entonces \\(\\gamma_1 (\\cdot)+\\gamma_2 (\\cdot)\\), es también un semivariograma válido en \\(\\mathbb{R}^d\\). Lo que equivale a suponer que el proceso \\(Z(\\cdot)\\) se obtiene como suma de dos procesos intrínsecamente estacionarios independientes: \\(Z(\\mathbf{s})=Z_1 (\\mathbf{s})+Z_2 (\\mathbf{s})\\), con semivariogramas \\(\\gamma_1 (\\cdot)\\) y \\(\\gamma_2 (\\cdot)\\) respectivamente. Un variograma isotrópico válido en \\(\\mathbb{R}^d\\) es también un variograma isotrópico válido en \\(\\mathbb{R}^m\\), \\(\\forall m\\leq d\\). Se suelen emplear estas propiedades para la obtención de modelos de variograma válidos, como por ejemplo en el caso de la anisotropía zonal (Sección 3.2.2) o del modelo lineal de (co)regionalización (secciones 3.2.3 y 5.X). 1.3.2 Procesos agregados En algunos casos los datos pueden ser agregaciones espaciales en lugar de observaciones puntuales (e incluso observaciones sobre distintos soportes) o, por ejemplo, puede ser de interés la estimación de medias espaciales a partir de datos puntuales. Estas agregaciones pueden ser modeladas como el promedio de un proceso puntual, lo que permite deducir fácilmente las relaciones entre covariogramas y variogramas vinculados a diferentes soportes. Supongamos que el proceso espacial \\(Z(\\cdot)\\) definido sobre \\(D\\subset \\mathbb{R} ^{d}\\) es integrable en media cuadrática. Entonces, si \\(B\\subset D\\) es un subconjunto acotado e integrable con \\(\\left| B\\right| =\\int_B d\\mathbf{s} &gt; 0\\), se puede definir el proceso espacial agregado (también se denomina regularizado) como: \\[Z(B)\\equiv \\dfrac{1}{\\left| B\\right| } \\int_{B}Z(\\mathbf{s})d\\mathbf{s}.\\] Si por ejemplo el proceso puntual es intrínsecamente estacionario con semivariograma \\(\\gamma (\\cdot)\\), entonces a partir del variograma puntual podemos obtener el variograma del proceso agregado: \\[\\begin{aligned} Var\\left( Z(B_1)-Z(B_2)\\right) = &amp; -\\dfrac{1}{\\left| B_1 \\right| ^{2} } \\int_{B_1 }\\int_{B_1 }\\gamma(\\mathbf{s}-\\mathbf{u})d\\mathbf{s}d\\mathbf{u} \\\\ &amp; -\\dfrac{1}{\\left| B_2 \\right|^{2} } \\int_{B_2}\\int_{B_2}\\gamma(\\mathbf{s}-\\mathbf{u})d\\mathbf{s}d\\mathbf{u} \\\\ &amp; +\\dfrac{1}{\\left| B_1 \\right| \\left| B_2 \\right| } \\int_{B_1 }\\int_{B_2} 2\\gamma(\\mathbf{s}-\\mathbf{u})d\\mathbf{s}d\\mathbf{u}. \\end{aligned}\\] Aunque nos centraremos principalmente en el caso de soporte puntual, los métodos descritos en este libro pueden ser extendidos para el caso de distintos soportes (por ejemplo el block kriging descrito en la Sección 4.X). Sin embargo, en la práctica pueden aparecer dificultades, especialmente al combinar observaciones en distintos soportes (esto es lo que se conoce como el problema de cambio de soporte, o el modifiable areal unit problem, MAUP). Para más detalles ver por ejemplo Cressie (1993, Sección 5.2) ó Chilès y Delfiner (1999, Sección 2.4). Suponiendo que \\(\\lim \\limits_{\\left\\| \\mathbf{h}\\right\\| \\rightarrow \\infty } C(\\mathbf{h})=0\\). Además de poder interpretar su influencia en la predicción espacial (Sección 4.X), son utilizadas en la parametrización de la mayoría de los modelos de variogramas o covariogramas (Sección 3.2.1). El origen de esta denominación esta relacionado con la terminología minera. En algunos yacimientos de metal, como por ejemplo en el caso del oro, el mineral suele obtenerse como pepitas de material puro y estas pepitas normalmente son más pequeñas que el tamaño de la unidad de muestreo (lo que produce una variabilidad adicional en la muestra). "],["objetivos-esquema.html", "1.4 Objetivos y pasos", " 1.4 Objetivos y pasos A partir de los valores observados \\(\\{Z(\\mathbf{s}_1), \\ldots, Z(\\mathbf{s}_n)\\}\\) (o \\(\\{Z(B_1), \\ldots, Z(B_n)\\}\\)), los objetivos suelen ser: Obtener predicciones (kriging) \\(\\hat{Z}(\\mathbf{s}_0)\\) (o \\(\\hat{Z}(B_0)\\)). Realizar inferencias (estimación, contrastes) sobre las componentes del modelo \\(\\hat{\\mu}(\\cdot)\\), \\(\\hat{\\gamma}(\\cdot)\\). Obtención de mapas de riesgo \\(P({Z}(\\mathbf{s}_0)\\geq c)\\). Realizar inferencias sobre la distribución (condicional) de la respuesta en nuevas localizaciones En cualquier caso en primer lugar habría que estimar las componentes del modelo: la tendencia \\(\\mu(\\mathbf{s})\\) y el semivariograma \\(\\gamma(\\mathbf{h})\\). La aproximación tradicional (paramétrica) para el modelado de un proceso geoestadístico consiste en los siguientes pasos: Análisis exploratorio y formulación de un modelo paramétrico inicial (Capítulo 2). Estimación de los parámetros del modelo (proceso iterativo; Capítulo 3): Estimar y eliminar la tendencia. Modelar la dependencia (ajustar un modelo de variograma) a partir de los residuos. Validación del modelo (Sección 4.X) o reformulación del mismo. Empleo del modelo aceptado (Capítulo 4). Como ya se comentó, emplearemos el paquete gstat en este proceso. "],["el-paquete-gstat.html", "1.5 El paquete gstat", " 1.5 El paquete gstat El paquete gstat permite la modelización geoestadística (univariante, Capítulo 3, y multivariante, Capítulo 5), espacial y espacio-temporal (Capítulo 6), incluyendo predicción y simulación (Capítulo 4 y secciones 5.X y 6.X). library(gstat) Este paquete implementa su propia estructura de datos (S3, basada en data.frame) pero también es compatible con los objetos Spatial* del paquete sp (Apéndice A) y los objetos de datos de los paquetes sf y stars (Capítulo 2). Para más información se pueden consultar la referencia, las viñetas del paquete: The meuse data set: a tutorial for the gstat R package, Spatio-Temporal Geostatistics using gstat, Introduction to Spatio-Temporal Variography, el blog r-spatial o las correspondientes publicaciones (Pebesma, 2004; Gräler, Pebesma y Heuvelink, 2016). Este paquete de R es una evolución de un programa independiente anterior con el mismo nombre (Pebesma y Wesseling, 1998; basado en la librería GSLIB, Deutsch y Journel, 1992). Puede resultar de interés consultar el manual original para información adicional sobre los detalles computacionales. "],["datos.html", "Capítulo 2 Datos espaciales", " Capítulo 2 Datos espaciales En este capítulo se incluye una breve introducción a los tipos de datos espaciales (Sección 2.1) y a su manipulación en R con el paquete sf (secciones 2.2 y 2.4). La parte final se centra en el análisis exploratorio de datos espaciales (Sección 2.5). "],["datos-tipos.html", "2.1 Tipos de datos espaciales", " 2.1 Tipos de datos espaciales En el campo de los datos espaciales se suele distinguir entre dos tipos de datos: Datos vectoriales: en los que se emplean coordenadas para definir las posiciones espaciales exactas de los datos. Entre ellos estarían los asociados a las geometrías habituales: puntos, líneas, polígonos y rejillas. Datos ráster: se utilizan habitualmente para representar una superficie continua. Un ráster no es más que una rejilla regular que determina un conjunto de rectángulos denominados celdas (o píxeles en el análisis de imágenes de satélite y teledetección) que tienen asociados uno o más valores. Este tipo de datos también se denominan arrays o data cubes espaciales (o espacio-temporales). El valor de una celda ráster suele ser el valor medio (o el total) de una variable en el área que representa (se trataría de observaciones de un proceso agregado, descritos en la Sección 1.3.2), aunque en algunos casos es el valor puntual correspondiente al centro de la celda (nodo de una rejilla vectorial). En este libro entenderemos que ráster hace referencia a agregaciones espaciales y nos centraremos principalmente en datos vectoriales (incluyendo rejillas de datos), aunque hoy en día cada vez es más habitual disponer de datos ráster gracias a la fotografía aérea y a la teledetección por satélite. Como se comentó en la Sección 1.3.2, muchos métodos geoestadísticos admiten datos en distintos soportes (por ejemplo el block kriging descrito en la Sección 4.X), aunque combinar datos en diferentes soportes puede presentar en la práctica serias dificultades (para más detalles ver referencias al final de la Sección 1.3.2). Como ya se comentó en la Sección 1.1, dependiendo de las suposiciones sobre el soporte del proceso (índice espacial) se distingue entre distintos tipos de procesos espaciales. Sin embargo, aunque en principio los objetivos pueden ser muy distintos, en todos estos casos se trabaja con datos similares (espaciales y espacio-temporales): Procesos geoestadísticos (índice espacial continuo): Datos: coordenadas y valores observados (puntos y datos), opcionalmente se pueden considerar los límites de una región de observación o de múltiples regiones (polígonos). Resultados: superficie de predicción (rejilla), opcionalmente predicciones por área (polígonos y datos, o raster). Procesos reticulares/regionales (índice espacial discreto): Datos: límites de regiones y valores asociados (polígonos y datos, , o raster). Resultados: estimaciones por área (polígonos y datos, o raster). Procesos puntuales (indice espacial aleatorio): Datos: coordenadas (puntos), opcionalmente con valores asociados (procesos marcados; puntos y datos), límites región de observación (polígonos). Resultados: superficie de incidencia o probabilidad (rejilla). Este es el principal motivo de que se hayan desarrollado paquetes de R para facilitar su manipulación (y permitiendo el intercambio de datos entre herramientas). Entre ellos destacan: sp (Classes and methods for spatial data, E. J. Pebesma y Bivand, 2005): se corresponde con Bivand et al. (2013) y emplea clases S4. Se complementa con los paquetes rgdal (interfaz a la geospatial data abstraction library, para la lectura y escritura de datos espaciales) y rgeos (interfaz a la librería Geometry Engine Open Source, para operaciones geométricas). sf (Simple Features for R, E. Pebesma, 2018): alternativa en desarrollo con objetos más simples S3 (compatible con tidyverse y que proporciona una interfaz directa a las librerías GDAL y GEOS) que aspira a reemplazar el paquete sp a corto plazo. Se corresponde con E. Pebesma y Bivand (2021) (disponible online). El paquete sp tiene un soporte limitado para datos ráster, este es uno de los motivos por los que surgió el paquete raster, que actualmente está siendo reemplazado por el paquete terra (información sobre estos paquetes está disponible en el manual online). El paquete sf no implementa datos ráster (y tiene un soporte muy limitado para rejillas de datos), para manejar este tipo de datos se complementa con el paquete starts (Spatiotemporal Arrays: Raster and Vector Datacubes). Para detalles sobre la conversión entre datos ráster y datos vectoriales ver por ejemplo las secciones 7.5 y 7.7 de E. Pebesma y Bivand (2021). En este capítulo emplearemos el paquete sf para la manipulación de datos espaciales, aunque en el Apéndice A se incluye una breve introducción a las clases sp, ya que este tipo de objetos siguen siendo ampliamente empleados en la actualidad (y, de momento, algunas de las herramientas disponibles en R solo admiten las clases de datos definidas en este paquete). References Bivand, R. S., Pebesma, E., y Gómez-Rubio, V. (2013). Applied Spatial Data Analysis with R (Second). Springer. http://www.asdar-book.org/ Pebesma, E. (2018). Simple Features for R: Standardized Support for Spatial Vector Data. The R Journal, 10(1), 439-446. https://doi.org/10.32614/RJ-2018-009 Pebesma, E., y Bivand, R. (2021). Spatial Data Science. https://keen-swartz-3146c4.netlify.app Pebesma, E. J., y Bivand, R. S. (2005). Classes and methods for spatial data in R. R News, 5(2), 9-13. https://CRAN.R-project.org/doc/Rnews/ "],["sf-intro.html", "2.2 Introducción al paquete sf", " 2.2 Introducción al paquete sf El modelo de geometrías de características simples (o rasgos simples) es un estándar (ISO 19125) desarrollado por el Open Geospatial Consortium (OGC) para formas geográficas vectoriales, que ha sido adoptado por gran cantidad de software geográfico (entre otros por GeoJSON, ArcGIS, QGIS, PostGIS, MySQL Spatial Extensions, Microsoft SQL Server). Como ya se comentó, este tipo de datos espaciales está implementado en R en el paquete sf. Los objetos principales, del tipo sf, son extensiones de data.frame (o tibble) y como mínimo contienen una columna denominada simple feature geometry list column que contiene la geometría de cada observación (se trata de una columna tipo list). Cada fila, incluyendo la geometría y otras posibles variables (denominados atributos de la geometría), se considera una característica simple (SF). library(sf) ## Linking to GEOS 3.9.1, GDAL 3.2.1, PROJ 7.2.1 nc &lt;- st_read(system.file(&quot;shape/nc.shp&quot;, package=&quot;sf&quot;), quiet = TRUE) nc &lt;- nc[c(5, 9:15)] nc ## Simple feature collection with 100 features and 7 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 ## Geodetic CRS: NAD27 ## First 10 features: ## NAME BIR74 SID74 NWBIR74 BIR79 SID79 NWBIR79 ## 1 Ashe 1091 1 10 1364 0 19 ## 2 Alleghany 487 0 10 542 3 12 ## 3 Surry 3188 5 208 3616 6 260 ## 4 Currituck 508 1 123 830 2 145 ## 5 Northampton 1421 9 1066 1606 3 1197 ## 6 Hertford 1452 7 954 1838 5 1237 ## 7 Camden 286 0 115 350 2 139 ## 8 Gates 420 0 254 594 2 371 ## 9 Warren 968 4 748 1190 2 844 ## 10 Stokes 1612 1 160 2038 5 176 ## geometry ## 1 MULTIPOLYGON (((-81.47276 3... ## 2 MULTIPOLYGON (((-81.23989 3... ## 3 MULTIPOLYGON (((-80.45634 3... ## 4 MULTIPOLYGON (((-76.00897 3... ## 5 MULTIPOLYGON (((-77.21767 3... ## 6 MULTIPOLYGON (((-76.74506 3... ## 7 MULTIPOLYGON (((-76.00897 3... ## 8 MULTIPOLYGON (((-76.56251 3... ## 9 MULTIPOLYGON (((-78.30876 3... ## 10 MULTIPOLYGON (((-80.02567 3... str(nc) ## Classes &#39;sf&#39; and &#39;data.frame&#39;: 100 obs. of 8 variables: ## $ NAME : chr &quot;Ashe&quot; &quot;Alleghany&quot; &quot;Surry&quot; &quot;Currituck&quot; ... ## $ BIR74 : num 1091 487 3188 508 1421 ... ## $ SID74 : num 1 0 5 1 9 7 0 0 4 1 ... ## $ NWBIR74 : num 10 10 208 123 1066 ... ## $ BIR79 : num 1364 542 3616 830 1606 ... ## $ SID79 : num 0 3 6 2 3 5 2 2 2 5 ... ## $ NWBIR79 : num 19 12 260 145 1197 ... ## $ geometry:sfc_MULTIPOLYGON of length 100; first list element: List of 1 ## ..$ :List of 1 ## .. ..$ : num [1:27, 1:2] -81.5 -81.5 -81.6 -81.6 -81.7 ... ## ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## - attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ## - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA NA NA NA NA NA ## ..- attr(*, &quot;names&quot;)= chr [1:7] &quot;NAME&quot; &quot;BIR74&quot; &quot;SID74&quot; &quot;NWBIR74&quot; ... El nombre de la columna de geometrías está almacenado en el atributo \"sf_column\" del objeto y se puede acceder a ella mediante la función st_geometry() (además de poder emplear los procedimientos habituales para acceder a los componentes de un data.frame). Esta columna es un objeto de tipo sfc (simple feature geometry list column), descritos más adelante. # geom_name &lt;- attr(nc, &quot;sf_column&quot;) # nc[, geom_name]; nc[[geom_name]] # nc$geometry st_geometry(nc) ## Geometry set for 100 features ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 ## Geodetic CRS: NAD27 ## First 5 geometries: ## MULTIPOLYGON (((-81.47276 36.23436, -81.54084 3... ## MULTIPOLYGON (((-81.23989 36.36536, -81.24069 3... ## MULTIPOLYGON (((-80.45634 36.24256, -80.47639 3... ## MULTIPOLYGON (((-76.00897 36.3196, -76.01735 36... ## MULTIPOLYGON (((-77.21767 36.24098, -77.23461 3... En este paquete, todos los métodos y funciones que operan sobre datos espaciales comienzan por st_ (spatial type; siguiendo la implementación de PostGIS): methods(class=&quot;sf&quot;) ## [1] $&lt;- [ [[&lt;- ## [4] aggregate as.data.frame cbind ## [7] coerce dbDataType dbWriteTable ## [10] filter identify initialize ## [13] merge plot print ## [16] rbind show slotsFromS3 ## [19] st_agr st_agr&lt;- st_area ## [22] st_as_s2 st_as_sf st_bbox ## [25] st_boundary st_buffer st_cast ## [28] st_centroid st_collection_extract st_convex_hull ## [31] st_coordinates st_crop st_crs ## [34] st_crs&lt;- st_difference st_filter ## [37] st_geometry st_geometry&lt;- st_inscribed_circle ## [40] st_interpolate_aw st_intersection st_intersects ## [43] st_is st_is_valid st_join ## [46] st_line_merge st_m_range st_make_valid ## [49] st_nearest_points st_node st_normalize ## [52] st_point_on_surface st_polygonize st_precision ## [55] st_reverse st_sample st_segmentize ## [58] st_set_precision st_shift_longitude st_simplify ## [61] st_snap st_sym_difference st_transform ## [64] st_triangulate st_union st_voronoi ## [67] st_wrap_dateline st_write st_z_range ## [70] st_zm transform ## see &#39;?methods&#39; for accessing help and source code Los objetos geométricos básicos son del tipo sfg (simple feature geometry) que contienen la geometría de una única característica definida a partir de puntos en dos (XY), tres (XYZ, XYM) o cuatro dimensiones (XYZM). Admite los 17 tipos de geometrías simples del estándar, pero de forma completa los 7 tipos básicos: Tipo Description Creación POINT, MULTIPOINT Punto o conjunto de puntos st_point(), st_multipoint() LINESTRING, MULTILINESTRING Línea o conjunto de líneas st_linestring(), st_multilinestring() POLYGON, MULTIPOLYGON Polígono6 o conjunto de polígonos st_polygon(), st_multipolygon() GEOMETRYCOLLECTION Conjunto de geometrías de los tipos anteriores st_geometrycollection() Las geometrías se imprimen empleando la representación well-known text (WKT) del estándar (se exportan empleando la representación well-known binary, WKB). nc$geometry[[1]] ## MULTIPOLYGON (((-81.47276 36.23436, -81.54084 36.27251, -81.56198 36.27359, -81.63306 36.34069, -81.74107 36.39178, -81.69828 36.47178, -81.7028 36.51934, -81.67 36.58965, -81.3453 36.57286, -81.34754 36.53791, -81.32478 36.51368, -81.31332 36.4807, -81.26624 36.43721, -81.26284 36.40504, -81.24069 36.37942, -81.23989 36.36536, -81.26424 36.35241, -81.32899 36.3635, -81.36137 36.35316, -81.36569 36.33905, -81.35413 36.29972, -81.36745 36.2787, -81.40639 36.28505, -81.41233 36.26729, -81.43104 36.26072, -81.45289 36.23959, -81.47276 36.23436))) Los objetos básicos sfg (normalmente del mismo tipo) se pueden combinar en un objeto sfc (simple feature geometry list column) mediante la función st_sfg(). Estos objetos pueden incorporar un sistema de referencia de coordenadas (por defecto NA_crs_), descritos en la Sección 2.2.1. Posteriormente se puede crear un objeto sf mediante la función st_sf(). p1 &lt;- st_point(c(-8.395835, 43.37087)) p2 &lt;- st_point(c(-7.555851, 43.01208)) p3 &lt;- st_point(c(-7.864641, 42.34001)) p4 &lt;- st_point(c(-8.648053, 42.43362)) sfc &lt;- st_sfc(list(p1, p2, p3, p4)) cprov &lt;- st_sf(names = c(&#39;Coruña (A)&#39;, &#39;Lugo&#39;, &#39;Ourense&#39;, &#39;Pontevedra&#39;), geom = sfc) cprov ## Simple feature collection with 4 features and 1 field ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: -8.648053 ymin: 42.34001 xmax: -7.555851 ymax: 43.37087 ## CRS: NA ## names geom ## 1 Coruña (A) POINT (-8.395835 43.37087) ## 2 Lugo POINT (-7.555851 43.01208) ## 3 Ourense POINT (-7.864641 42.34001) ## 4 Pontevedra POINT (-8.648053 42.43362) Esta forma de proceder puede resultar de interés cuando se construyen geometrías tipo líneas o polígonos, pero en el caso de datos puntuales (las observaciones habituales en geoestadística), resulta mucho más cómodo emplear un data.frame que incluya las coordenadas en columnas y convertirlo a un objeto sf mediante la función st_as_sf(). Ejercicio 2.1 (Creación de una columna de geometrías) Crear una geometría (un objeto sfc) formada por: dos puntos en las posiciones (1,5) y (5,5), una línea entre los puntos (1,1) y (5,1), y un polígono, con vértices {(0,0), (6,0), (6,6), (0,6), (0,0)} y con un agujero con vértices {(2,2), (2,4), (4,4), (4,2), (2,2)} (NOTA: consultar la ayuda ?st, puede resultar cómodo emplear matrix(... , ncol = 2, byrow = TRUE)). Como ejemplo consideraremos el conjunto de datos meuse del paquete sp que contiene concentraciones de metales pesados, junto con otras variables del terreno, en una zona de inundación del río Meuse (cerca de Stein, Holanda)7 (ver Figura 2.1). data(meuse, package=&quot;sp&quot;) str(meuse) ## &#39;data.frame&#39;: 155 obs. of 14 variables: ## $ x : num 181072 181025 181165 181298 181307 ... ## $ y : num 333611 333558 333537 333484 333330 ... ## $ cadmium: num 11.7 8.6 6.5 2.6 2.8 3 3.2 2.8 2.4 1.6 ... ## $ copper : num 85 81 68 81 48 61 31 29 37 24 ... ## $ lead : num 299 277 199 116 117 137 132 150 133 80 ... ## $ zinc : num 1022 1141 640 257 269 ... ## $ elev : num 7.91 6.98 7.8 7.66 7.48 ... ## $ dist : num 0.00136 0.01222 0.10303 0.19009 0.27709 ... ## $ om : num 13.6 14 13 8 8.7 7.8 9.2 9.5 10.6 6.3 ... ## $ ffreq : Factor w/ 3 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ soil : Factor w/ 3 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;: 1 1 1 2 2 2 2 1 1 2 ... ## $ lime : Factor w/ 2 levels &quot;0&quot;,&quot;1&quot;: 2 2 2 1 1 1 1 1 1 1 ... ## $ landuse: Factor w/ 15 levels &quot;Aa&quot;,&quot;Ab&quot;,&quot;Ag&quot;,..: 4 4 4 11 4 11 4 2 2 15 ... ## $ dist.m : num 50 30 150 270 380 470 240 120 240 420 ... # ?meuse # Sistema de coordenadas Rijksdriehoek (RDH) (Netherlands topographical) # https://epsg.io/28992 # EPSG:28992 meuse_sf &lt;- st_as_sf(meuse, coords = c(&quot;x&quot;, &quot;y&quot;), crs = 28992, agr = &quot;constant&quot;) # Rio Meuse data(meuse.riv, package=&quot;sp&quot;) str(meuse.riv) ## num [1:176, 1:2] 182004 182137 182252 182315 182332 ... meuse_riv &lt;- st_sfc(st_polygon(list(meuse.riv)), crs = 28992) # Rejilla data(meuse.grid, package=&quot;sp&quot;) str(meuse.grid) ## &#39;data.frame&#39;: 3103 obs. of 7 variables: ## $ x : num 181180 181140 181180 181220 181100 ... ## $ y : num 333740 333700 333700 333700 333660 ... ## $ part.a: num 1 1 1 1 1 1 1 1 1 1 ... ## $ part.b: num 0 0 0 0 0 0 0 0 0 0 ... ## $ dist : num 0 0 0.0122 0.0435 0 ... ## $ soil : Factor w/ 3 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ ffreq : Factor w/ 3 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;: 1 1 1 1 1 1 1 1 1 1 ... meuse_grid &lt;- st_as_sf(meuse.grid, coords = c(&quot;x&quot;, &quot;y&quot;), crs = 28992, agr = &quot;constant&quot;) # Almacenar # save(meuse_sf, meuse_riv, meuse_grid, file = &quot;datos/st_meuse.RData&quot;) # Representar plot(meuse_sf[&quot;zinc&quot;], pch = 16, cex = 1.5, main = &quot;&quot;, breaks = &quot;quantile&quot;, key.pos = 4, reset = FALSE) plot(meuse_riv, col = &quot;lightblue&quot;, add = TRUE) plot(st_geometry(meuse_grid), pch = 3, cex = 0.2, col = &quot;lightgray&quot;, add = TRUE) Figura 2.1: Concentración de zinc (ppm) en el entorno del río Meuse (datos sp::meuse). Ejercicio 2.2 (Creación y representación de datos espaciales) Cargar los datos del acuífero Wolfcamp (aquifer.RData), generar el correspondiente objeto sf y representarlo mostrando los ejes. 2.2.1 Sistemas de referencia de coordenadas El sistema de referencia de coordenadas (CRS) especifica la correspondencia entre valores de las coordenadas y puntos concretos en la superficie de la Tierra (o del espacio), y resulta fundamental cuando se combinan datos espaciales. En general se consideran dos tipos de CRS: Geodésico: las coordenadas en tres dimensiones (latitud, longitud y altura) se basan en un elipsoide de referencia (global o local) que sirve como aproximación del globo terrestre (se tiene en cuenta que no es una esfera perfecta e incluso que puede haber variaciones locales). Este elipsoide, junto con información adicional sobre como interpretar las coordenadas (incluyendo el orden y el origen), define el denominado datum. Normalmente se asume que las coordenadas son en la superficie terrestre y solo se consideran: latitud: ángulo entre el plano ecuatorial y la línea que une la posición con el centro de la Tierra. Varía desde -90 (polo sur) hasta 90 (polo norte). Un grado equivale aproximadamente a 110.6 km. Los paralelos son las líneas en la superficie terrestre correspondientes a la misma latitud (siendo el 0 el ecuador). longitud: ángulo (paralelo al plano ecuatorial) entre un meridiano de referencia (arco máximo que une los polos pasando por una determinado punto, normalmente el observatorio de Greenwich) y la línea que une la posición con el centro de la Tierra. Varía desde -180 (oeste) hasta 180 (este). Un grado en el ecuador equivale a aproximadamente a 111.3 km. Los meridianos son las líneas en la superficie terrestre correspondientes a la misma longitud (siendo el 0 el meridiano de Greenwich y -180 o 180 el correspondiente antimeridiano). La rejilla correspondiente a un conjunto de paralelos y meridianos se denomina gratícula (ver st_graticule()). Figura 2.2: Coordenadas geográficas en la superficie terrestre (Fuente Wikimedia Commons). Uno de los CRS más empleados es el WGS84 (World Geodetic System 1984) en el que se basa el Sistema de Posicionamiento Global (GPS). Proyectado (cartesiano): sistema (local) en dos dimensiones que facilita algún tipo de cálculo (normalmente distancias o áreas). Por ejemplo el UTM (Universal Transverse Mercator), que emplea coordenadas en metros respecto a una cuadrícula de referencia (se divide la tierra en 60 husos de longitud, numerados, y 20 bandas de latitud, etiquetadas con letras; por ejemplo Galicia se encuentra en la cuadricula 29T). Se define relacionando estas coordenadas cartesianas con coordenadas geodésicas con un determinado datum. En sf se emplea la librería PRØJ para definir el CRS y convertir coordenadas en distintos sistemas8. Para obtener o establecer el CRS se puede emplear la función st_crs(). Se puede especificar mediante una cadena de texto que admita GDAL (por ejemplo \"WGS84\", que se corresponde con el World Geodetic System 1984), que típicamente es de la forma ESTÁNDAR:CÓDIGO (también puede ser una cadena de texto PROJ.4). El estándar más empleado es el EPSG (European Petroleum Survey Group), y es que que da por hecho el paquete sf cuando se especifica el CRS mediante un número. También admite el estándar OGC WKT (Open Geospatial Consortium well-known text) que es el que emplea internamente, pero resulta complicado manejar en la práctica. st_crs(&quot;WGS84&quot;) ## Coordinate Reference System: ## User input: WGS84 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;World Geodetic System 1984&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;geodetic latitude (Lat)&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;geodetic longitude (Lon)&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4326]] all.equal(st_crs(4326), st_crs(&quot;EPSG:4326&quot;), st_crs(&quot;WGS84&quot;)) ## [1] TRUE st_crs(nc) ## Coordinate Reference System: ## User input: NAD27 ## wkt: ## GEOGCRS[&quot;NAD27&quot;, ## DATUM[&quot;North American Datum 1927&quot;, ## ELLIPSOID[&quot;Clarke 1866&quot;,6378206.4,294.978698213898, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;latitude&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;longitude&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4267]] En spatialreference.org se puede obtener información detallada sobre una gran cantidad de proyecciones (y permite realizar búsquedas). También puede ser de utilidad epsg.io o este listado con detalles de los parámetros. El CRS ideal dependerá del tipo de problema y de la zona cubierta por los datos (ver e.g Lovelace et al, 2021, Sección 6.3, para más información). En general en estadística espacial nos interesará trabajar con coordenadas proyectadas, de forma que tenga sentido emplear la distancia euclídea (algo que puede ser poco o nada razonable si se trabaja con coordenadas geodésicas en una zona muy amplia del globo o cerca de los polos). En el caso de coordenadas sin proyectar (latitud/longitud) puede ser preferible trabajar con distancias ortodrómicas (longitud del arco del círculo máximo que une los puntos, great circle distances)9. Es importante destacar que cambiar el CRS no reproyecta los datos, hay que emplear st_transform() para hacerlo, como se describe en la Sección 2.4. Finalmente hay que insistir también en que el campo de aplicación de la estadística espacial no se restringe al análisis de datos geográficos (por ejemplo nos puede interesar analizar el desgaste en la pared de un crisol empleado en fundición) y en estos casos los CRS geográficos carecen de sentido. De todos modos habrá que emplear un sistema de coordenadas que permita calcular algún tipo de salto o distancia entre puntos (aunque siempre se pueden considerar coordenadas espaciales tres dimensiones con la distancia euclídea). 2.2.2 Integración con el ecosistema tidyverse El paquete sf es compatible con tidyverse y proporciona métodos para interactuar con los paquetes dplyr, tidyr y ggplot2. Algunos de los métodos de interés para manipular datos espaciales con el paquete dplyr son: filter(), select(), mutate(), summarise(..., do_union = TRUE, is_coverage = FALSE), group_by(), ungroup(), etc. inner_join(), left_join(), right_join(), full_join(), semi_join(), anti_join(), st_join(). st_drop_geometry(), st_set_crs(). Para detalles ver la referencia. En el caso del paquete ggplot2 se puede consultar la referencia y el tutorial Drawing beautiful maps programmatically with R, sf and ggplot2: Part 1: Basics (General concepts illustrated with the world Map). Part 2: Layers (Adding additional layers: an example with points and polygons). Part 3: Layouts (Positioning and layout for complex maps). Por ejemplo, se puede generar un gráfico similar al de la Figura 1.2 (porcentaje de incremento de las defunciones en el año 2020 respecto al 2019 en las CCAA españolas; datos provisionales INE), con el siguiente código: library(dplyr) library(mapSpain) mortalidad &lt;- read.csv2(&quot;datos/mortalidad.csv&quot;) CCAA_sf &lt;- esp_get_ccaa() %&gt;% left_join(mortalidad) %&gt;% mutate(incremento = 100*(mort.2020 - mort.2019)/mort.2019) library(ggplot2) ggplot(CCAA_sf) + geom_sf(aes(fill = incremento), color = &quot;grey70&quot;) + scale_fill_gradientn(colors = hcl.colors(10, &quot;Blues&quot;, rev = TRUE)) + geom_sf_label(aes(label = paste0(round(incremento, 1), &quot;%&quot;)), alpha = 0.5) + geom_sf(data = esp_get_can_box(), color = &quot;grey70&quot;) + theme_void() Figura 2.3: Ejemplo de gráfico generado empleando los paquetes dplyr y ggplot2. Sin embargo, en este libro se supone que no se está familiarizado con estas herramientas y se evitará su uso (aunque pueden resultar más cómodas después de su aprendizaje). Para una introducción a dplyr, ver por ejemplo la viñeta Introduction to dplyr, el Capítulo 5 del libro R for Data Science o el Capítulo 4 de los apuntes Prácticas de Tecnologías de Gestión y Manipulación de Datos. No obstante, en ciertas ocasiones emplearemos el operador pipe %&gt;% (tubería, redirección) por comodidad. Este operador permite canalizar la salida de una función a la entrada de otra. Por ejemplo segundo(primero(datos)) se traduce en datos %&gt;% primero %&gt;% segundo (facilitando la lectura de expresiones de izquierda a derecha). Secuencia de puntos que forma un anillo cerrado, que no se interseca; el primero anillo definen el anillo exterior, anillos posteriores definen agujeros. Según la norma, los puntos del anillo exterior deben especificarse en sentido contrario a las agujas del reloj y los de los agujeros en sentido de las agujas del reloj. Empleado en la viñeta del paquete gstat con el paquete sp. El paquete sf admite las últimas versiones PROJ 5 y 6, incluyendo el formato WKT-2 de 2019, mientras que el paquete sp está diseñado para cadenas de texto PROJ.4 que se recomiendan abandonar (las últimas versiones permiten añadir una cadena WKT2 como comment). Algo que ya hace de forma automática el paquete gstat. "],["representación-de-datos-espaciales.html", "2.3 Representación de datos espaciales", " 2.3 Representación de datos espaciales El paquete sf implementa métodos plot() para la representación de objetos espaciales (ver ?plot.sf). Estos métodos suelen ser la forma más rápida de generar gráficos básicos (estáticos), pero también se pueden emplear otros paquetes como ggplot2 (Sección 2.2.2), tmap, mapsf, leaflet, mapview, mapdeck o ggmap, para generar mapas más avanzados, incluyendo mapas dinámicos. Para una introducción a las posibilidades gráficas con el paquete sf se puede consultar la viñeta Plotting Simple Features. El método plot() es de la forma: plot(x, ..., max.plot, pal = NULL, nbreaks, breaks = &quot;pretty&quot;, key.pos, key.length, key.width, extent = x, axes = FALSE, graticule = NA_crs_, col_graticule = &quot;grey&quot;, border, reset = TRUE) x: objeto de tipo sf o sfc. max.plot: número máximo de atributos que se representarán. pal: función que genera la paleta de colores (ver e.g. ?rainbow), por defecto sf.colors (ver Figura 2.4). nbreaks: número de puntos de corte para la clave de color. breaks: vector de puntos de corte o cadena de texto válida para el argumento style de classIntervals (ver figuras: 2.1, 2.4). key.pos: posición de la leyenda, -1 = automática, 0 = error?, 1 = abajo, 2 = izquierda, 3 = arriba, 4 = derecha, NULL = omitir. Cuando se representan múltiples atributos se añade una única leyenda común únicamente si se establece (ver figuras: 2.4, 2.8). key.length, key.width: dimensiones de la leyenda (proporción de espacio). extent: objeto con método st_bbox() para definir los límites (sustituyendo a xlim e ylim). axes: lógico; TRUE para dibujar los ejes. graticule: lógico, objeto de clase crs (st_crs()) u objeto creado por st_graticule; TRUE representará la gratícula st_graticule(x) (ver Figura 2.8). col_graticule: color de la gratícula. border: color de los bordes de polígonos. reset: lógico; si el gráfico contiene una leyenda se modifican los parámetros gráficos y por defecto los restaura (reset = TRUE). Solo en ese caso es necesario establecer reset = FALSE para continuar añadiendo elementos, con add = TRUE (para restaurarlos hay que ejecutar dev.off()) (ver figuras: 2.1, 2.4). ...: otros parámetros gráficos (ver ?plot.default y ?par). Ejemplo: library(viridis) plot(nc[c(&quot;SID74&quot;, &quot;SID79&quot;)], pal = viridis, border = &#39;grey70&#39;, logz = TRUE, breaks = seq(0, 2, len = 9), at = c(0, 0.5, 1, 1.5, 2), key.pos = 1, key.width = lcm(1.2), key.length = 0.8) Figura 2.4: Ejemplo de gráfico con múltiples atributos (con colores personalizados y leyenda común, en escala logarítmica personalizada). El paquete tmap permite generar mapas temáticos con una gramática similar a la de ggplot2 pero enfocada a mapas. Por defecto crea mapas estáticos (tmap_mode(\"plot\")): library(tmap) tm_shape(nc) + tm_polygons(&quot;SID79&quot;) Figura 2.5: Ejemplo de mapa estático creado con tmap. Aunque puede crear mapas interactivos, en páginas html, utilizando el paquete leaflet (interfaz a la librería JavaScript Leaflet), implementando también leyendas, ventanas emergentes al pulsar con el ratón en las características y soporte para datos rasterizados. tmap_mode(&quot;view&quot;) tmap_last() # Error en bookdown Para más información ver el capítulo Making maps with R del libro Geocomputation with R, la viñeta del paquete, o el borrador del libro Elegant and informative maps with tmap. El paquete mapview también permite crear mapas interactivos utilizando el paquete leaflet (con funcionalidades añadidas) o el paquete mapdeck (diseñado para grandes conjuntos de datos espaciales). library(mapview) mapview(nc, zcol = &quot;SID79&quot;) # Error en bookdown Para más información ver las viñetas del paquete. "],["operaciones-datos.html", "2.4 Operaciones con datos espaciales", " 2.4 Operaciones con datos espaciales A continuación se describe una selección de las herramientas disponibles para datos espaciales. Para un listado completo de las funciones implementadas en el paquete sf se puede consultar la referencia (o la chuleta, aunque puede contener algunos errores). Puede que algunas herramientas (o recursos) admitan únicamente objetos Spatial* del paquete sp, aunque siempre se pueden emplear las funciones para convertir tipos de objetos: st_as_sf(x, ...): convierte x a un objeto sf (por ejemplo objetos Spatial*). as(x, \"Spatial\"): convierte x a un objeto Spatial*. 2.4.1 Importación y exportación de datos espaciales El paquete sf permite importar y exportar una gran cantidad de formatos de datos espaciales, almacenados en ficheros o en bases de datos, mediante las funciones st_read() y st_write(). Como se mostró al principio de la Sección 2.2, estas funciones deducen el formato automáticamente a partir de la extensión del archivo (por ejemplo .shp para ESRI Shapefile) o a partir del prefijo (por ejemplo PG: para PostGIS/PostgreSQL): dir &lt;- system.file(&quot;shape&quot;, package=&quot;sf&quot;) list.files(dir, pattern=&quot;^[nc]&quot;) ## [1] &quot;nc.dbf&quot; &quot;nc.prj&quot; &quot;nc.shp&quot; &quot;nc.shx&quot; # ESRI Shapefile, consta de por lo menos de 3 ficheros, el principal .shp file &lt;- paste0(dir, &quot;/nc.shp&quot;) file ## [1] &quot;C:/Program Files/R/R-4.1.1/library/sf/shape/nc.shp&quot; nc_sf &lt;- st_read(file) ## Reading layer `nc&#39; from data source ## `C:\\Program Files\\R\\R-4.1.1\\library\\sf\\shape\\nc.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 100 features and 14 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 ## Geodetic CRS: NAD27 Se admiten los formatos de datos vectoriales soportados por GDAL (que emplea internamente), se puede obtener un listado con la función st_drivers(): drivers &lt;- st_drivers() str(drivers) ## &#39;data.frame&#39;: 89 obs. of 7 variables: ## $ name : chr &quot;ESRIC&quot; &quot;FITS&quot; &quot;PCIDSK&quot; &quot;netCDF&quot; ... ## $ long_name: chr &quot;Esri Compact Cache&quot; &quot;Flexible Image Transport System&quot; &quot;PCIDSK Database File&quot; &quot;Network Common Data Format&quot; ... ## $ write : logi FALSE TRUE TRUE TRUE TRUE TRUE ... ## $ copy : logi FALSE FALSE FALSE TRUE TRUE TRUE ... ## $ is_raster: logi TRUE TRUE TRUE TRUE TRUE TRUE ... ## $ is_vector: logi TRUE TRUE TRUE TRUE TRUE TRUE ... ## $ vsi : logi TRUE FALSE TRUE FALSE TRUE TRUE ... Figura 2.6: Listado de drivers en la instalación (local) de GDAL`. Además, se han desarrollado una gran cantidad de paquetes de R que permiten acceder directamente desde R a datos espaciales. Muchos incluyen conjuntos de datos espaciales y otros implementan interfaces a bases de datos espaciales o geoportales disponibles en Internet. Algunos de ellos son los siguientes: rnaturalearth: permite importar una gran cantidad de datos vectoriales y rasterizados de Natural Earth, incluyendo datos administrativos/culturales (fronteras de países, aeropuertos, carreteras, vías férreas) y físicos (costas, lagos). giscoR: permite importar datos de Eurostat - GISCO (Geographic Information System of the COmmission). mapSpain: permite importar límites administrativos de España (CCAA, provincias, municipios). osmdata: permite importar pequeños conjuntos de datos de OpenStreetMap (OSM). osmextract: permite importar grandes conjuntos de datos de OSM. ows4R: (en desarrollo) proporciona una interfaz para OGC standard Web-Services (OWS). openeo: permite importar datos de servidores openEO (Open Earth Observation data). rnoaa: permite importar datos climáticos de la National Oceanic and Atmospheric Administration (NOAA). climaemet: permite importar datos climáticos proporcionados por la Agencia Estatal de Meteorología de España (AEMET). meteoForecast: permite importar resultados de los modelos numéricos de predicción meteorológica GFS, MeteoGalicia, NAM y RAP. saqgetr: permite importar datos de calidad del aire de Europa. RGISTools: permite importar datos de imágenes de satélite de Landsat, MODIS y Sentinel. maptools,spData,spDataLarge,getlandsat library(osmdata) # Cuidado: descarga mucha información # https://nominatim.openstreetmap.org/ui/search.html # https://wiki.openstreetmap.org/wiki/Map_features osm_coru &lt;- opq(&#39;A Coruña&#39;) %&gt;% add_osm_feature(key = &#39;highway&#39;) %&gt;% osmdata_sf() plot(st_geometry(osm_coru$osm_lines), main = &quot;&quot;, xlim = c(-8.45, -8.38), ylim = c(43.32, 43.39)) Figura 2.7: Representación de las carreteras, calles y caminos en A Coruña (generado con el paquete osmdata). También están disponibles una gran cantidad de páginas web y geoportales desde donde es posible descargar datos espaciales (algo que se puede hacer directamente desde R). Algunas de ellas son: CGADM database of Global Administrative Areas: permite descargar límites administrativos a distintos niveles (e.g. 0 = pais, 1 = CCAA, 2 = provincias, 3 = comarcas, 4 = ayuntamientos). NASA Earth Science Data. INSPIRE Geoportal: Enhancing access to European spatial data. Copernicus Open Access Hub: Europes eyes on Earth. GSHHG A Global Self-consistent, Hierarchical, High-resolution Geography Database. Muchos de los archivos de datos están en formato NetCDF (Network Common Data Form) y se pueden importar a R con el paquete ncdf4. 2.4.2 Operaciones con geometrías Operaciones unarias (operan sobre un único conjunto de geometrías simples, el primer argumento) con resultado geométrico: st_geometry(): devuelve (o establece) la columna sfc de un objeto sf. st_transform(x, crs, ...): transforma o convierte las coordenadas de x a un nuevo sistema de referencia. st_cast(x, to, ...): cambia la geometría x a otro tipo de geometría. st_centroid(): devuelve los centroides de las geometrías. st_buffer(): crea un buffer en torno a la geometría o a cada geometría. st_boundary(): devuelve la frontera de la geometría. st_convex_hull(): crea el envoltorio convexo de un conjunto de puntos. st_voronoi(): crea una teselación de Voronoi. st_make_grid(x, cellsize, offset, n, what = c(\"polygons\", \"corners\", \"centers\")): genera una rejilla rectangular (o exagonal) de geometrías (what) que cubre los límites de x. Como ya se comentó en la Sección 2.2.1, nos puede interesar transformar las coordenadas a un nuevo sistema de referencia (algo necesario para poder combinar conjuntos de datos espaciales con distintos CRS). Por ejemplo podemos utilizar la proyección de Mollweide para representar datos globales (en este caso estimaciones de la población de países; Figura 2.8 derecha). library(rnaturalearth) par_old &lt;- par(mfrow = c(1, 2), mar = c(bottom = 0, left = 0, top = 0, right = 0)) # NOTA: plot.sf() con escala no es compatible con mfrow world_pop &lt;- ne_countries(returnclass = &quot;sf&quot;)[&quot;pop_est&quot;] plot(world_pop, logz = TRUE, main = &quot;&quot;, key.pos = NULL, reset = FALSE) grat &lt;- st_graticule(crs=st_crs(&quot;WGS84&quot;), lon = seq(-180, 180, by = 20), lat = seq(-90, 90, by = 10)) plot(grat[1], col = &#39;darkgray&#39;, add = TRUE) # https://spatialreference.org/ref/esri/54009/ world_pop2 &lt;- st_transform(world_pop, &quot;ESRI:54009&quot;) plot(world_pop2, logz = TRUE, main = &quot;&quot;, key.pos = NULL, reset = FALSE) grat &lt;- st_graticule(world_pop2, lon = seq(-180, 180, by = 20), lat = seq(-90, 90, by = 10)) plot(grat[1], col = &#39;darkgray&#39;, add = TRUE) Figura 2.8: Mapa de la población estimada por paises (en escala logarítmica), datos sin proyectar (izquierda) y con proyección de Mollweide (derecha). par(par_old) Operaciones binarias (operan sobre dos conjuntos de geometrías simples) con resultado geométrico: st_union(x, y, ..., by_feature): une varias geometrías. st_intersection(x, y, ...): intersección de pares de geometrías. st_crop(x, y, ..., xmin, ymin, xmax, ymax): intersección con rectángulo delimitador o especificado. st_difference(x, y, ...): diferencia de pares de geometrías. st_sym_difference(x, y, ...): diferencia simétrica (xor) de pares de geometrías. st_nearest_points(x, y, ...): obtiene los puntos más cercanos entre pares de geometrías. Operaciones unarias con resultado numérico o lógico: st_coordinates(x): devuelve una matriz con las coordenadas. st_bbox(obj, ...): devuelve los límites del conjunto de geometrías. st_area(x, ...): devuelve el área de polígonos. st_length(x, ...): devuelve la longitud de líneas. st_is(x, type): verifica si la geometría es de un determinado tipo o conjunto de clases. Operaciones binarias con resultado numérico o lógico: st_distance(x, y, ..., by_element, which): devuelve la matriz de distancias mínimas entre geometrías. st_nearest_feature(x, y): devuelve el índice de la geometría de y más cercana a cada geometría de x. st_intersects(x, y, ...): determina si las geometrías se solapan o tocan. st_disjoint(x, y, ...): determina si las geometrías no se solapan o tocan. st_touches(x, y, ...): determina si las geometrías se tocan. st_overlaps(x, y, ...): determina si las geometrías se solapan, pero no están completamente contenidas la una en la otra. st_crosses(x, y, ...): determina si las geometrías se cruzan, pero no se tocan. st_within(x, y, ...): determina si x está en y. st_contains(x, y, ...): determina si y está en x. st_covers(x, y, ...): determina si todos los puntos de y están dentro de x. st_covered_by(x, y, ...): determina si todos los puntos de x están dentro de y. st_equals(x, y, ...): determina si x es geométricamente igual a y. st_equals_exact(x, y, par, ...): determina si x es igual a y con cierta tolerancia. El resultado de las operaciones lógicas es una matriz dispersa (de clase sgbp, sparse geometry binary predicate), que se puede convertir a una matriz densa con as.matrix(). Ejercicio 2.3 (Creación de una rejilla de predicción) Continuando con los datos del Ejercicio 2.2, generar un buffer (st_buffer()) de radio 40 en torno a las posiciones espaciales, a partir de él crear una rejilla vectorial (st_make_grid(..., what = \"centers\")) de dimensiones 50 por 50 e intersecarla con el buffer. Representar todos los objetos. "],["sp-eda.html", "2.5 Análisis exploratorio de datos espaciales", " 2.5 Análisis exploratorio de datos espaciales Como se comentó en la Sección 1.4, el primer paso para estimar las componentes del modelo, la tendencia \\(\\mu(\\mathbf{s})\\) y el semivariograma \\(\\gamma(\\mathbf{h})\\), es realizar un análisis exploratorio de los datos. Normalmente comenzaremos por un análisis descriptivo de la respuesta. Sería deseable que su distribución fuese aproximadamente simétrica (de forma que los métodos basados en mínimos cuadrados sean adecuados). Si además la distribución es aproximadamente normal (después de eliminar la tendencia) tendría sentido emplear métodos basados en máxima verosimilitud (Sección 3.3.3). Si su distribución es muy asimétrica se puede pensar en transformarla como punto de partida (aunque podría cambiarse posteriormente dependiendo del modelo final para la tendencia). load(&quot;datos/aquifer.RData&quot;) str(aquifer) ## &#39;data.frame&#39;: 85 obs. of 3 variables: ## $ lon : num 42.78 -27.4 -1.16 -18.62 96.47 ... ## $ lat : num 127.6 90.8 84.9 76.5 64.6 ... ## $ head: num 1464 2553 2158 2455 1756 ... library(sf) aquifer_sf &lt;- st_as_sf(aquifer, coords = c(&quot;lon&quot;, &quot;lat&quot;), agr = &quot;constant&quot;) z &lt;- aquifer_sf$head/100 summary(z) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 10.24 15.48 17.97 20.02 25.40 35.71 hist(z, xlab = &quot;piezometric-head&quot;, main = &quot;&quot;, freq = FALSE) lines(density(z), col = &#39;blue&#39;) Figura 2.9: Distribución del nivel del agua subterránea en el acuífero Wolfcamp. En un segundo paso se podría tener en cuenta las coordenadas espaciales. Por ejemplo, podríamos generar un gráfico de dispersión para ver si se observa algún patrón claro (lo que nos haría sospechar que la tendencia no es constante). plot(aquifer_sf, pch = 20, cex = 3, breaks = &quot;quantile&quot;, nbreaks = 4) Figura 2.10: Distribución espacial de las observaciones del nivel del agua subterránea en el acuífero Wolfcamp. Gráficos de dispersión de la respuesta frente a las coordenadas nos pueden ayudar a determinar si hay una tendencia (al estilo de las funciones geoR::plot.geodata() o npsp::scattersplot()): coord &lt;- st_coordinates(aquifer_sf) old.par &lt;- par(mfrow = c(1, 2), omd = c(0.05, 0.95, 0.01, 0.95)) plot(coord[, 1], z, xlab = &quot;x&quot;, ylab = &quot;z&quot;) lines(lowess(coord[, 1], z), lty = 2, lwd = 2, col = &#39;blue&#39;) plot(coord[, 2], z, xlab = &quot;y&quot;, ylab = &quot;z&quot;) lines(lowess(coord[, 2], z), lty = 2, lwd = 2, col = &#39;blue&#39;) Figura 2.11: Gráficos de dispersión del nivel del agua subterránea frente a coordenadas (acuífero Wolfcamp). par(old.par) En este caso concreto parece que una tendencia lineal es adecuada. Ejercicio 2.4 (Análisis exploratorio de la tendencia) Realizar un análisis exploratorio del conjunto de datos s100 del paquete geoR (que contiene una simulación de un proceso espacial estacionario, sin tendencia; ver Sección 3.1). Ejercicio 2.5 (Análisis exploratorio con variables explicativas) Realizar un análisis exploratorio del conjunto de datos meuse_sf (almacenado en el archivo st_meuse.RData; ver Figura 2.1) considerando como respuesta la concentración de zinc y como variables explicativas, además de las coordenadas espaciales, las variables que comparte con la rejilla meuse_grid (y que se podrían emplear en la predicción kriging; Capítulo 4). Realizar también un análisis exploratorio multivariante, considerando la respuesta y el resto de variables explicativas (que podrían considerarse realizaciones de otros procesos espaciales y emplearlas para predicción multivariante, cokriging; Capítulo 5). Para el análisis exploratorio de la dependencia se suelen emplear las semivarianzas muestrales o los estimadores experimentales del variograma, como se describe en la Sección 3.1. "],["modelado.html", "Capítulo 3 Modelado de procesos geoestadísticos", " Capítulo 3 Modelado de procesos geoestadísticos En preparación Como se comentó en la Sección 1.4 la aproximación tradicional (paramétrica) para el modelado de un proceso geoestadístico, es decir, estimar la tendencia \\(\\mu(\\mathbf{s})\\) y el semivariograma \\(\\gamma(\\mathbf{h})\\), consiste en los siguientes pasos: Análisis exploratorio y formulación de un modelo paramétrico (inicial). Estimación de los parámetros del modelo: Estimar y eliminar la tendencia (suponiendo que no es constante). Modelar la dependencia (ajustar un modelo de variograma) a partir de los residuos (o directamente de las observaciones si la tendencia se supone constante). Validación del modelo o reformulación del mismo. Empleo del modelo aceptado. El procedimiento habitual para el modelado de la dependencia en el paso 2 (también denominado análisis estructural) consiste en obtener una estimación inicial del semivariograma utilizando algún tipo de estimador experimental (Sección 3.1) y posteriormente ajustar un modelo paramétrico válido de semivariograma a las estimaciones piloto obtenidas en el primer paso (secciones 3.2 y 3.3). El principal problema con esta aproximación aparece cuando no se puede asumir que la tendencia es constante, ya que los estimadores muestrales descritos en la siguiente sección solo son adecuados para procesos estacionarios. En este caso, como la media es constante, entonces: \\[\\begin{equation} E(Z(\\mathbf{s}_1) - Z(\\mathbf{s}_{2}))^2 = 2\\gamma(\\mathbf{s}_1 -\\mathbf{s}_{2}), \\ \\forall \\mathbf{s}_1 ,\\mathbf{s}_{2} \\in D. \\tag{3.1} \\end{equation}\\] Sin embargo, cuando la tendencia no es constante: \\[\\begin{equation} E(Z(\\mathbf{s}_1) - Z(\\mathbf{s}_{2}))^2 = 2\\gamma(\\mathbf{s}_1 - \\mathbf{s}_{2}) + \\left( \\mu(\\mathbf{s}_1)-\\mu(\\mathbf{s}_{2})\\right)^2, \\tag{3.2} \\end{equation}\\] y no es necesariamente función de \\(\\mathbf{s}_1 -\\mathbf{s}_{2}\\), ni tiene por qué verificar las propiedades de un variograma. Por este motivo, estos estimadores no deben ser utilizados mientras que no se elimine la tendencia de los datos. Si no se puede asumir que la tendencia es constante, para poder estimarla de forma eficiente sería necesario conocer la dependencia (i.e. conocer \\(\\gamma(\\cdot)\\)). Este problema circular se suele resolver en la práctica realizando el paso 2 de forma iterativa, como se describe en la Sección 3.3.2. Otra alternativa sería asumir normalidad y estimar ambos componentes de forma conjunta empleando alguno de los métodos basados en máxima verosimilitud descritos en la Sección 3.3.3. Finalmente, en el paso 3, para verificar si el modelo (de tendencia y variograma) describe adecuadamente la variabilidad espacial de los datos (y para comparar modelos), se emplea normalmente la técnica de validación cruzada, descrita en la Sección 4.X del siguiente capítulo (en el que también se describe los principales métodos empleados en el paso 4). "],["vario-muestrales.html", "3.1 Estimadores muestrales del semivariograma", " 3.1 Estimadores muestrales del semivariograma Suponiendo que el proceso es intrísecamente estacionario, a partir de (3.1), empleando el método de los momentos, se obtiene el denominado estimador empírico (o clásico) del semivariograma (Matheron, 1962): \\[\\hat{\\gamma}(\\mathbf{h}) = \\dfrac{1}{2\\left| N(\\mathbf{h})\\right| } \\sum\\limits_{N(\\mathbf{h})}\\left( Z(\\mathbf{s}_{i})-Z(\\mathbf{s}_{j} )\\right) ^2 ,\\ \\mathbf{h}\\in \\mathbb{R}^{d},\\] donde: \\[N(\\mathbf{h}) = \\left\\{ (i,j):\\mathbf{s}_{i} -\\mathbf{s}_{j} \\in Tol(\\mathbf{h});i,j=1,\\ldots,n\\right\\},\\] \\(Tol(\\mathbf{h})\\subset \\mathbb{R}^{d}\\) es una región de tolerancia en torno a \\(\\mathbf{h}\\) y \\(\\left| N(\\mathbf{h})\\right|\\) es el número de pares distintos en \\(N(\\mathbf{h})\\). La región de tolerancia debería ser lo suficientemente grande como para que no aparezcan inestabilidades, por lo que se recomienda (Journel y Huijbregts 1978, p.194) que el numero de aportaciones a la estimación en un salto \\(\\mathbf{h}\\) sea por lo menos de treinta (i.e. \\(\\left| N(\\mathbf{h})\\right| \\geq 30\\)). De forma análoga, suponiendo estacionariedad de segundo orden, se obtiene el estimador clásico del covariograma: \\[\\hat{C} (\\mathbf{h}) = \\dfrac{1}{\\left| N(\\mathbf{h})\\right| } \\sum\\limits_{N(\\mathbf{h})}\\left( Z(\\mathbf{s}_{i})-\\bar{Z} \\right) \\left( Z(\\mathbf{s}_{j})-\\bar{Z} \\right),\\ \\mathbf{h}\\in \\mathbb{R}^{d},\\] siendo \\(\\bar{Z} =\\frac{1}{n} \\sum_{i=1}^{n}Z(\\mathbf{s}_{i})\\) la media muestral. El principal problema con este estimador es la necesidad de estimar la media \\(\\mu\\) del proceso, lo que produce que sea sesgado. Por otra parte, además de que la suposición de estacionariedad de segundo orden es menos general (Sección 1.3, si el proceso es intrínsecamente estacionario el estimador del variograma es insesgado y también tiene mejores propiedades cuando la estimación se basa en residuos (aunque en este caso ambos estimadores son sesgados). Más información sobre la distribución y propiedades de estos estimadores se tienen por ejemplo en Cressie (1993, pp. 71-74). Estos resultados justifican que el modelado de la dependencia espacial se realice a través del semivariograma. Uno de los problemas con el estimador empírico del semivariograma es su falta de robustez frente a observaciones atípicas. Por este motivo se han propuesto numerosas alternativas robustas. Hawkins y Cressie (1984) sugirieron promediar la raíz cuadrada de las diferencias en valor absoluto10 y posteriormente transformar el resultado a la escala original tratando de obtener un estimador aproximadamente insesgado (utilizando del método delta), obteniéndose el estimador: \\[2\\tilde{\\gamma}(\\mathbf{h}) = \\left( \\dfrac{1}{\\left| N(\\mathbf{h})\\right| } \\sum\\limits_{N(\\mathbf{h})}\\left| Z(\\mathbf{s}_{i})-Z(\\mathbf{s}_{j} )\\right|^{\\frac{1}{2} } \\right)^{4} /\\left( \\text{0.457+} \\dfrac{\\text{0.494} }{\\left| N(\\mathbf{h})\\right| } +\\dfrac{\\text{0.045} }{\\left| N(\\mathbf{h})\\right|^2 } \\right).\\] Los estimadores locales tipo núcleo son herramientas frecuentemente utilizadas en la estimación de curvas y superficies. Entre los más conocidos podemos señalar los estimadores tipo Nadaraya-Watson y los polinómicos locales (e.g. Fan y Gijbels,1996). Recientemente se han considerado también estas ideas para la estimación del covariograma (e.g. Hall et al., 1994) y del semivariograma. La expresión general de un estimador no paramétrico de un semivariograma isotrópico es de la forma: \\[\\hat{\\gamma}(r) = \\dfrac{\\sum\\limits_{i=1}^{n-1}\\sum\\limits_{j=i+1}^{n}\\omega_{ij} (r)\\left( Z(\\mathbf{s}_{i})-Z(\\mathbf{s}_{j})\\right)^2 }{2\\sum\\limits_{i=1}^{n-1}\\sum\\limits_{j=i+1}^{n}\\omega_{ij}(r)},\\] donde \\(\\omega_{ij}(r) \\geq 0\\), \\(\\forall i,j\\) y \\(\\sum_{i,j}\\omega_{ij}(r) &gt; 0\\). Dependiendo de la elección de estos pesos obtenemos distintos estimadores: \\(\\omega_{ij}(r) = \\mathcal{I}_{Tol(r)} \\left( \\left\\| \\mathbf{s}_{i} - \\mathbf{s}_{j} \\right\\| \\right)\\), siendo \\(Tol(r)\\subset \\mathbb{R}\\) una región de tolerancia en torno a \\(r\\) (y denotando por \\(\\mathcal{I}_{A}(\\cdot)\\) función indicadora del conjunto \\(A\\)), obtenemos el estimador clásico del semivariograma. \\(\\omega_{ij}(r)=K\\left( \\frac{\\left\\| \\mathbf{s}_{i} -\\mathbf{s}_{j} \\right\\| -r}{h} \\right)\\), es el estimador Nadaraya-Watson (Hall et al., 1994). \\(\\omega_{ij}(r)=K\\left( \\frac{\\left\\| \\mathbf{s}_{i} -\\mathbf{s}_{j} \\right\\| -r}{h} \\right) \\times\\) \\(\\sum\\limits_{k}\\sum\\limits_{l}K\\left( \\frac{\\left\\| \\mathbf{s}_{k} -\\mathbf{s}_{l} \\right\\| -r}{h} \\right) \\left( \\left\\| \\mathbf{s}_{k} -\\mathbf{s}_{l} \\right\\| -r\\right) \\left( \\left\\| \\mathbf{s}_{k} -\\mathbf{s}_{l} \\right\\| -\\left\\| \\mathbf{s}_{i} -\\mathbf{s}_{j} \\right\\| \\right)\\) se obtiene el estimador lineal local del semivariograma (García-Soidán et al., 2003). La función variogram() del paquete gstat: variogram(formula, locations = coordinates(data), data, cutoff, width = cutoff/15, cressie = FALSE, cloud = FALSE, covariogram = FALSE, ...) permite obtener la nube de semivarianzas (cloud = TRUE) y las estimaciones empíricas o robustas (cressie = TRUE), además de otras posibilidades. En primer lugar emplearemos el conjunto de datos s100 del paquete geoR, que contiene una simulación de un proceso espacial estacionario (sin tendencia). # Cargamos los datos y los transformamos a un objeto `sf` library(sf) ## Linking to GEOS 3.9.1, GDAL 3.2.1, PROJ 7.2.1 data(s100, package = &quot;geoR&quot;) datos &lt;- st_as_sf(data.frame(s100$coords, z = s100$data), coords = 1:2, agr = &quot;constant&quot;) library(gstat) vario.cloud &lt;- variogram(z ~ 1, datos, cloud = TRUE, cutoff = 0.6) vario &lt;- variogram(z ~ 1, datos, cloud = FALSE, cutoff = 0.6) # Si se quiere tomar el 50% del máximo salto (posible) cutoff = maxlag # maxlag &lt;- 0.5*sqrt(sum(diff(apply(s100$coord, 2, range))^2)) # maxlag &lt;- 0.5*sqrt(sum(diff(matrix(st_bbox(datos), nrow = 2, byrow = TRUE))^2)) names(vario) ## [1] &quot;np&quot; &quot;dist&quot; &quot;gamma&quot; &quot;dir.hor&quot; &quot;dir.ver&quot; &quot;id&quot; NOTA: La componente dist contiene los saltos, gamma las estimaciones del semivariograma (semivarianzas) y np el número de aportaciones. rvario.cloud &lt;- variogram(z ~ 1, datos, cloud = TRUE, cressie = TRUE, cutoff = 0.6) rvario &lt;- variogram(z ~ 1, datos, cloud = FALSE, cressie = TRUE, cutoff = 0.6) # Representar oldpar &lt;- par(mfrow = c(1, 2)) # Clásico with(vario.cloud, plot(dist, gamma, col = &quot;darkgray&quot;, xlab = &quot;distance&quot;, ylab = &quot;semivariance&quot;)) with(vario, points(dist, gamma, pch = 19)) # Robusto with(rvario.cloud, plot(dist, gamma, col = &quot;darkgray&quot;, xlab = &quot;distance&quot;, ylab = &quot;semivariance&quot;)) with(rvario, points(dist, gamma, pch = 19)) par(oldpar) Para detectar observaciones atípicas podríamos emplear la nube de semivarianzas (robustas, con una distribución más próxima a la normalidad): res &lt;- as.data.frame(rvario.cloud) boundaries &lt;- attr(rvario, &quot;boundaries&quot;) res$lag &lt;- cut(res$dist, breaks = boundaries, labels = seq_len(length(boundaries)-1)) res$labels &lt;- with(res, paste(left, right, sep=&quot;-&quot;)) with(res, car::Boxplot(gamma ~ lag, id = list(labels = labels))) ## [1] &quot;87-52&quot; &quot;87-39&quot; &quot;57-52&quot; &quot;57-39&quot; Nos preocuparía especialmente la presencia de datos atípicos en saltos pequeños (indicaría que observaciones cercanas tienen valores muy distintos). Para un análisis exploratorio de la anisotropía, podemos obtener variogramas direccionales indicando el ángulo y los grados de tolerancia en cada eje: plot(variogram(z ~ 1, datos, cutoff = 0.6, alpha = c(0, 45, 90, 135))) Complementariamente, se puede obtener un mapa de semivarianzas discretizadas en dos dimensiones: variogram.map &lt;- variogram(z ~ 1, datos, cutoff = 0.6, width = 0.6 / 15, map = TRUE) plot(variogram.map) Para estudiar si hay dependencia espacial (estadísticamente significativa) se puede emplear la rutina sm.variogram del paquete sm. Estableciendo model = \"independent\" devuelve un p-valor para contrastar la hipótesis nula de independencia (i.e. se acepta que hay una dependencia espacial si \\(p \\leq \\alpha = 0.05\\)) y un gráfico en el que se muestra el estimador empírico robusto, un estimador suavizado y una región de confianza para el variograma suponiendo que el proceso es independiente (i.e. consideraríamos que hay dependencia espacial si el variograma suavizado no está contenido en esa región). library(sm) ## Package &#39;sm&#39;, version 2.2-5.6: type help(sm) for summary information sm.variogram(s100$coords, s100$data, model = &quot;independent&quot;) ## Test of spatial independence: p = 0.024 También se puede realizar contrastes adicionales estableciendo el parámetro model a \"isotropic\" o \"stationary\". Si el proceso \\(Z(\\cdot)\\) es normal entonces \\((Z(\\mathbf{s})-Z(\\mathbf{s}+\\mathbf{h}))^2\\) sigue una distribución \\(2\\gamma(\\mathbf{h})\\chi_1^2\\), sin embargo esta distribución es muy asimétrica y la transformación de potencia que hace que se aproxime más a la simetría (normalidad) es la raíz cuarta. Otra ventaja de utilizar la raíz cuadrada de las diferencias es que, en general, están menos correladas que las diferencias al cuadrado (ver p.e. Cressie, 1993, p. 76). "],["modelos-variog.html", "3.2 Modelos de semivariogramas", " 3.2 Modelos de semivariogramas Los variogramas deben ser condicionalmente semidefinidos negativos, una propiedad que los estimadores tradicionales normalmente no poseen. Tradicionalmente esto se remedia ajustando un modelo paramétrico válido al estimador muestral (Sección 3.3). En la Sección 3.2.1 se presentan algunos de los modelos isotrópicos tradicionalmente utilizados en geoestadística. Estos modelos son empleados también en ciertos casos como estructuras básicas a partir de las cuales se construyen modelos más complejos, como modelos anisotrópicos (Sección 3.2.2) o los denominados modelos lineales de regionalización (Sección 3.2.3). 3.2.1 Modelos paramétricos isotrópicos A continuación se presentan algunos de los modelos isotrópicos de semivariograma más utilizados en geoestadística (una revisión más completa se tiene por ejemplo en Chilès y Delfiner, 1999, sección 2.5.1). En la notación utilizada en las parametrizaciones \\(c_{0} \\geq 0\\) representa el efecto nugget, \\(c_1 \\geq 0\\) el umbral parcial (en el caso de variogramas acotados, con \\(\\sigma^2= c_0 + c_1\\)) y \\(a&gt;0\\) el rango (si existe) o el parámetro de escala. En el caso de semivariogramas acotados que alcanzan el umbral asintóticamente (rango infinito), el parámetro \\(a\\) representa el rango práctico, definido como la distancia en la que el valor del semivariograma es el 95% del umbral parcial. En la Figura 3.1 se tienen algunos ejemplos de las formas de algunos de estos semivariogramas. Modelo esférico: \\[\\gamma(\\mathbf{h}\\left| \\boldsymbol{\\theta}\\right. ) = \\left\\{ \\begin{array}{ll} 0 &amp; \\text{si} \\left\\| \\mathbf{h}\\right\\| =0 \\\\ c_{0} +c_1 \\left\\{ \\dfrac{3}{2} \\dfrac{\\left\\| \\mathbf{h}\\right\\| }{a} -\\dfrac{1}{2} \\left( \\dfrac{\\left\\| \\mathbf{h}\\right\\| }{a} \\right) 3\\right\\} &amp; \\text{si} 0&lt;\\left\\| \\mathbf{h}\\right\\| \\leq a \\\\ c_{0} +c_1 &amp; \\text{si} \\left\\| \\mathbf{h}\\right\\| &gt;a \\end{array} \\right.\\] válido en \\(\\mathbb{R}^{d}\\), \\(d=1,2,3\\). Modelo exponencial: \\[\\gamma(\\mathbf{h}\\left| \\boldsymbol{\\theta}\\right. )\\ =\\ \\left\\{ \\begin{array}{ll} 0 &amp; \\text{si}\\ \\mathbf{h}=\\mathbf{0} \\\\ c_{0} + c_1 \\left( 1-\\exp \\left( -\\dfrac{3\\left\\| \\mathbf{h}\\right\\| }{a} \\right) \\right) &amp; \\text{si}\\ \\mathbf{h}\\neq \\mathbf{0} \\end{array} \\right.\\] válido en \\(\\mathbb{R}^{d}\\), \\(\\forall d \\geq 1\\). Modelo racional cuadrático: \\[\\gamma(\\mathbf{h}\\left| \\boldsymbol{\\theta}\\right. )\\ =\\ \\left\\{ \\begin{array}{ll} 0 &amp; \\text{si}\\ \\mathbf{h}=\\mathbf{0} \\\\ c_{0} + c_1 \\dfrac{\\left\\| \\mathbf{h}\\right\\|^2 }{\\frac{1}{19} a^2 +\\left\\| \\mathbf{h}\\right\\|^2 } &amp; \\text{si}\\ \\mathbf{h}\\neq \\mathbf{0} \\end{array} \\right.\\] válido en \\(\\mathbb{R}^{d}\\), \\(\\forall d \\geq 1\\). Modelo potencial: \\[\\gamma(\\mathbf{h}\\left| \\boldsymbol{\\theta}\\right. )\\ =\\ \\left\\{ \\begin{array}{ll} 0 &amp; \\text{si}\\ \\mathbf{h}=\\mathbf{0} \\\\ c_{0} + a\\left\\| \\mathbf{h}\\right\\|^{\\lambda } &amp; \\text{si}\\ \\mathbf{h}\\neq \\mathbf{0} \\end{array} \\right.\\] con \\(0\\leq \\lambda &lt;2\\) y válido en \\(\\mathbb{R}^{d}\\), \\(\\forall d \\geq 1\\). En el caso de \\(\\lambda =1\\) se obtiene el conocido modelo lineal. Modelo exponencial-potencial: \\[\\gamma(\\mathbf{h}\\left| \\boldsymbol{\\theta}\\right. )\\ =\\ \\left\\{ \\begin{array}{ll} 0 &amp; \\text{si}\\ \\mathbf{h}=\\mathbf{0} \\\\ c_{0} + c_1 \\left( 1-\\exp \\left( -3\\left( \\dfrac{\\left\\| \\mathbf{h}\\right\\| }{a} \\right)^{\\lambda } \\right) \\right) &amp; \\text{si}\\ \\mathbf{h}\\neq \\mathbf{0} \\end{array} \\right.\\] con \\(0\\leq \\lambda \\leq 2\\) y válido en \\(\\mathbb{R}^{d}\\), \\(\\forall d \\geq 1\\). Cuando \\(\\lambda =2\\) es denominado modelo gausiano; este modelo sin embargo no debería ser utilizado en la predicción espacial debido a las inestabilidades numéricas que produce en los algoritmos kriging (especialmente cuando el efecto nugget es grande; ver p.e. Wackernagel, 1998, pp. 120-123). El modelo exponencial se obtiene también como caso particular cuando \\(\\lambda =1\\). Modelo oscilatorio: \\[\\gamma(\\mathbf{h}\\left| \\boldsymbol{\\theta}\\right. )\\ =\\ \\left\\{ \\begin{array}{ll} 0 &amp; \\text{si}\\ \\mathbf{h}=\\mathbf{0} \\\\ c_{0} + c_1 \\left( 1-\\dfrac{a}{\\left\\| \\mathbf{h}\\right\\| } \\text{sen} \\left( \\dfrac{\\left\\| \\mathbf{h}\\right\\| }{a} \\right) \\right) &amp; \\text{si}\\ \\mathbf{h}\\neq \\mathbf{0} \\end{array} \\right.\\] válido en \\(\\mathbb{R}^{d}\\), \\(d=1,2,3\\). Este modelo con forma de onda (hay correlaciones negativas) alcanza su valor máximo ( \\(c_{0} +1.218c_1\\)) cuando \\(\\left\\| \\mathbf{h}\\right\\| \\simeq 4.5a\\), siendo \\(a\\) el parámetro de escala. Modelo de Matérn (o K-Bessel): \\[\\gamma(\\mathbf{h}\\left| \\boldsymbol{\\theta}\\right. )\\ =\\ \\left\\{ \\begin{array}{ll} 0 &amp; \\text{si}\\ \\mathbf{h}=\\mathbf{0} \\\\ c_{0} + c_1 \\left( 1-\\dfrac{1}{2^{\\nu -1} \\gamma(\\nu )} \\left( \\dfrac{\\left\\| \\mathbf{h}\\right\\| }{a} \\right)^{\\nu } K_{\\nu } \\left( \\dfrac{\\left\\| \\mathbf{h}\\right\\| }{a} \\right) \\right) &amp; \\text{si}\\ \\mathbf{h}\\neq \\mathbf{0} \\end{array} \\right.\\] siendo \\(\\nu \\geq 0\\) (un parámetro de suavizado) y \\(K_{\\nu }\\) la función de Bessel modificada de tercera clase de orden \\(\\nu\\) (ver p.e. Abramowitz y Stegun, 1965, pp. 374-379). Este modelo es válido en \\(\\mathbb{R}^{d}\\), \\(\\forall d \\geq 1\\). El modelo exponencial se obtiene como caso particular cuando \\(\\nu =\\frac{1}{2}\\) y en el límite \\(\\nu \\rightarrow \\infty\\) el modelo gausiano. En gstat se emplea la función vgm() (Variogram Model) para definir un modelo de variograma: vgm(psill = NA, model, range = NA, nugget, add.to, anis, kappa = 0.5, ...) psill: umbral parcial (\\(c_1\\)). model: cadena de texto que identifica el modelo (e.g. \"Exp\", \"Sph\", \"Gau\", \"Mat\"). range: rango o parámetro de escala (proporcional a \\(a\\)). nugget: efecto nugget (\\(c_0\\)). kappa: parametro de suavizado (\\(\\nu\\) en el modelo de Matérn). add.to: permite combinar modelos (Sección 3.2.3). anis: parámetros de anisotropía (Sección 3.2.2). Lo habitual es definir un modelo para posteriormente estimar sus parámetros utilizando los empleados en la definición como valores iniciales. También se puede llamar a esta función con el modelo como primer y único argumento, indicando que los parámetros son desconocidos (para que tome los valores por defecto en el ajuste). Por defecto considerará que el nugget es nulo (y no se estimará), únicamente se considerará un efecto nugget si se especifica, aunque sea nugget = NA. Si se ejecuta sin argumentos devuelve un listado de todos los modelos: vgm() ## short long ## 1 Nug Nug (nugget) ## 2 Exp Exp (exponential) ## 3 Sph Sph (spherical) ## 4 Gau Gau (gaussian) ## 5 Exc Exclass (Exponential class/stable) ## 6 Mat Mat (Matern) ## 7 Ste Mat (Matern, M. Stein&#39;s parameterization) ## 8 Cir Cir (circular) ## 9 Lin Lin (linear) ## 10 Bes Bes (bessel) ## 11 Pen Pen (pentaspherical) ## 12 Per Per (periodic) ## 13 Wav Wav (wave) ## 14 Hol Hol (hole) ## 15 Log Log (logarithmic) ## 16 Pow Pow (power) ## 17 Spl Spl (spline) ## 18 Leg Leg (Legendre) ## 19 Err Err (Measurement error) ## 20 Int Int (Intercept) La función show.vgms() genera gráficos con los distintos modelos (por defecto los 17 primeros): show.vgms() Figura 3.1: Representaciones de los modelos paramétricos isotrópicos de semivariogramas implementados en el paquete gstat. show.vgms(kappa.range = c(0.1, 0.5, 1, 5, 10), max = 10) Figura 3.2: Modelo de Matérn con distintos valores del parámetro de suavizado. v1 &lt;- vgm(psill = 1, model = &quot;Exp&quot;, range = 0.5, nugget = 0) v1 ## model psill range ## 1 Nug 0 0.0 ## 2 Exp 1 0.5 plot(v1, cutoff = 3) Figura 3.3: Ejemplo de modelo exponencial. 3.2.2 Modelado de anisotropía La hipótesis de isotropía simplifica notablemente el modelado de la dependencia espacial por lo que la mayoría de los modelos (básicos) de semivariogramas considerados en geoestadística son isotrópicos (Sección XX). Sin embargo, en muchos casos no se puede asumir que la dependencia es igual en cualquier dirección (uno de los ejemplos más claros es el caso espacio-temporal, donde en principio no es razonable pensar que un salto espacial es equivalente a un salto temporal). En esos casos se suelen considerar ligeras variaciones de la hipótesis de isotropía para modelar la dependencia espacial. En esta sección se comentan brevemente las distintas aproximaciones tradicionalmente consideradas en geoestadística (para más detalles ver p.e. Chilès y Delfiner, 1999, sección 2.5.2, o Goovaerts, 1997, sección 4.2.2), otras aproximaciones adicionales se tratarán en el Capítulo 7 (caso espacio-temporal). Cuando el variograma es función de la dirección además de la magnitud del salto, se dice que el variograma es anisotrópico (no isotrópico). Los tipos de anisotropía habitualmente considerados son: Anisotropía geométrica: cuando el umbral permanece constante mientras que el rango varía con la dirección. Anisotropía zonal: cuando el umbral del semivariograma varía con la dirección (también se denomina anisotropía estratificada). Combinación de las anteriores. La anisotropía geométrica se puede corregir mediante una transformación lineal del vector de salto \\(\\mathbf{h}\\): \\[\\gamma(\\mathbf{h})=\\gamma^{0} \\left( \\left\\| \\mathbf{A}\\mathbf{h}\\right\\| \\right) ,\\forall \\mathbf{h}\\in \\mathbb{R}^{d},\\] siendo \\(\\mathbf{A}\\) una matriz cuadrada \\(d\\times d\\) y \\(\\gamma^{0} (\\cdot)\\) un semivariograma isotrópico11. En este caso se dice que el variograma es geométricamente anisotrópico. Por ejemplo, en el caso bidimensional, se suele considerar una matriz de la forma: \\[\\mathbf{A}=\\left( \\begin{array}{cc} 1 &amp; 0 \\\\ 0 &amp; a_2/a_1 \\end{array} \\right) \\left( \\begin{array}{cc} \\cos \\phi &amp; \\sin\\phi \\\\ \\text{-} \\sin\\phi &amp; \\cos \\phi \\end{array} \\right),\\] que se corresponde con las direcciones principales de anisotropía \\(\\phi\\) y \\(\\phi + \\frac{\\pi }{\\text{2}}\\) (normalmente se toma \\(\\phi\\) igual a la dirección de máximo rango). Esto puede extenderse fácilmente para el caso tridimensional (ver p.e. Chilès y Delfiner, 1999, pp. 94-95). En gstat se puede definir anisotropía mediante el argumento anis de la función vgm(). En dos dimensiones es un vector con dos componentes anis = c(alpha, ratio), alpha es el ángulo para la dirección principal de variabilidad (en grados, medido en el sentido del reloj partiendo de la dirección norte, i.e. phi = (90 - alpha)*pi/180) y ratio la relación entre el rango mínimo y máximo (\\(0 \\leq ratio = a_2/a_1 \\leq 1\\)). Ejemplo: v &lt;- vgm(1, &quot;Exp&quot;, 5, anis = c(30, 0.1)) str(v) ## Classes &#39;variogramModel&#39; and &#39;data.frame&#39;: 1 obs. of 9 variables: ## $ model: Factor w/ 20 levels &quot;Nug&quot;,&quot;Exp&quot;,&quot;Sph&quot;,..: 2 ## $ psill: num 1 ## $ range: num 5 ## $ kappa: num 0.5 ## $ ang1 : num 30 ## $ ang2 : num 0 ## $ ang3 : num 0 ## $ anis1: num 0.1 ## $ anis2: num 1 plot_ellipse_2d &lt;- function(xc = 0, yc = 0, l1 = 10, l2 = 1, phi = pi/3, by = 0.01, asp = 1, ...) { # xc, yc: centro # l1, l2: longitud semiejes # phi: angulo del eje 1 respecto al eje x t &lt;- seq(0, 2*pi, by) x &lt;- xc + l1*cos(t)*cos(phi) - l2*sin(t)*sin(phi) y &lt;- yc + l1*cos(t)*sin(phi) + l2*sin(t)*cos(phi) plot(x, y, type = &quot;l&quot;, asp = asp, ...) } with(v, plot_ellipse_2d(l1 = range, l2 = range*anis1, phi = (90 - ang1)*pi/180)) abline(h = 0, lty = 2) abline(v = 0, lty = 2) En el caso de la anisotropía zonal se suele considerar una combinación de un semivariograma isotrópico más otros zonales que depende solamente de la distancia en ciertas direcciones (o componentes del vector de salto). Por ejemplo, en el caso bidimensional, si \\(\\phi\\) es la dirección de mayor varianza se suele considerar una combinación de la forma: \\[\\gamma(\\mathbf{h})=\\gamma_1 (\\left\\| \\mathbf{h}\\right\\|)+\\gamma_2(h_{\\phi }),\\] siendo \\(\\gamma_1 (\\cdot)\\) y \\(\\gamma_2 (\\cdot)\\) semivariogramas isotrópicos, y \\(h_{\\phi } =\\cos (\\phi)h_1 +\\sin(\\phi)h_2\\) el salto en la dirección \\(\\phi\\), para \\(\\mathbf{h}=(h_1 ,h_2)\\in \\mathbb{R} ^{2}\\). Es importante destacar que este tipo de anisotropías pueden causar la aparición de problemas al realizar predicción espacial (ver p.e. Myers y Journel, 1990; y Rouhani y Myers, 1990), como por ejemplo dar lugar a sistemas kriging no válidos con ciertas configuraciones de los datos. Hay que tener un especial cuidado cuando el covariograma es expresado como suma de covariogramas unidimensionales, en cuyo caso el resultado puede ser únicamente condicionalmente semidefinido positivo sobre un dominio multidimensional. Este tipo de modelos son casos particulares del modelo lineal de regionalización descrito en la siguiente sección. Una variante de la anisotropía zonal es el caso de covariogramas separables (también denominados factorizables) en componentes del vector de salto. Por ejemplo, un covariograma completamente separable en \\(\\mathbb{R}^2\\) es de la forma \\(C(h_1, h_2)= C_1(h_1)C_2(h_2)\\), siendo \\(C_1(\\cdot)\\) y \\(C_2(\\cdot)\\) covariogramas en \\(\\mathbb{R}^{1}\\). En este caso se puede pensar que el proceso espacial se obtiene como producto de procesos unidimensionales independientes definidos sobre cada uno de los ejes de coordenadas. Este tipo de modelos se utilizan habitualmente en geoestadística espacio-temporal (aunque no permiten modelar interacciones). 3.2.3 El modelo lineal de regionalización A partir de las propiedades 1 y 2 del semivariograma mostradas en la Sección 1.3.1, se obtienen los denominados modelos lineales de regionalización (también modelos anidados o nested models): \\[\\gamma(\\mathbf{h}) = \\sum\\limits_{k=0}^{q}b_{k} \\gamma_{k}(\\mathbf{h}),\\] siendo \\(b_k \\ge 0\\) y \\(\\gamma_{k}(\\mathbf{h})\\) modelos básicos de semivariogramas, \\(k=1, \\ldots, q\\). La denominación de modelos lineales surge porque estos modelos se obtienen al suponer que el proceso espacial es una combinación lineal procesos espaciales intrínsecamente estacionarios mutuamente independientes. Los modelos básicos suelen incluir un efecto nugget y algunos de los modelos mostrados en la sección anterior con efecto nugget nulo y umbral unidad. Además, cada modelo básico puede incorporar algún tipo de anisotropía (Sección 3.2.2), típicamente anisotropía geométrica: \\[\\gamma_{k}(\\mathbf{h})\\equiv \\gamma_{k}^{} \\left( \\left\\| \\mathbf{A}_{k} \\mathbf{h}\\right\\| \\right)\\] siendo \\(\\mathbf{A}_{k} ,k=0,\\ldots,q\\) matrices \\(d\\times d\\). De esta forma los modelos pueden ser lo suficientemente flexibles como para modelar la mayoría de situaciones que se pueden presentar en la práctica. Sin embargo, es difícil establecer un procedimiento automático (o semi-automático) para la selección y el ajuste de este tipo de modelos. Esto provoca que el proceso normalmente se realice en la práctica de forma interactiva por el usuario y utilizando principalmente herramientas gráficas12; siendo por tanto poco recomendables para algunos casos. En primer lugar hay que especificar el número y tipo de estructuras básicas, y en segundo lugar (aunque se suele hacer en la práctica de forma simultánea) está el problema de la estimación de los parámetros, donde puede ser especialmente complicado la determinación de los rangos y los parámetros de anisotropía de los distintos componentes (es de esperar que aparezcan problemas en la optimización). En gstat se pueden definir modelos de este tipo empleando el parámetro add.to de la función vgm(). v2 &lt;- vgm(psill = 1, model = &quot;Gau&quot;, range = 0.5) v12 &lt;- vgm(psill = 1, model = &quot;Gau&quot;, range = 0.5, add.to = v1) v12 ## model psill range ## 1 Nug 0 0.0 ## 2 Exp 1 0.5 ## 3 Gau 1 0.5 # Cuidado con plot.variogramModel() si se pretende añadir elementos plot(variogramLine(v12, maxdist = 3), type = &quot;l&quot;, ylim = c(0, 2.25)) lines(variogramLine(v1, maxdist = 3), col = &quot;red&quot;, lty = 2) lines(variogramLine(v2, maxdist = 3), col = &quot;blue&quot;, lty = 3) legend(&quot;bottomright&quot;, c(&quot;Exponencial&quot;, &quot;Gaussiano&quot;, &quot;Anidado&quot;), lty = c(2, 3, 1), col = c(&quot;red&quot;, &quot;blue&quot;, &quot;black&quot;), cex = 0.75) Esta idea (que el espacio euclídeo no es apropiado para medir distancias entre posiciones espaciales pero una transformación lineal de él sí) ha sido también generalizada para el caso de deformaciones no lineales del espacio. Por ejemplo, Sampson y Guttorp (1992) consideraron transformaciones no lineales obtenidas mediante técnicas de escalamiento óptimo multidimensional. Ver por ejemplo Goovaerts (1997, sección 4.2.4) para detalles sobre el uso en la práctica de éste tipo de modelos. "],["ajuste-variog.html", "3.3 Ajuste de un modelo válido", " 3.3 Ajuste de un modelo válido Como ya se comentó anteriormente, en general los estimadores del variograma no pueden ser usados directamente en la predicción espacial; no son condicionalmente semidefinidos negativos y eso puede causar por ejemplo sistemas kriging inválidos o estimaciones negativas de la varianza kriging. Este problema normalmente se remedia buscando un modelo paramétrico válido que describa adecuadamente la dependencia espacial presente en los datos. Supongamos que \\(P=\\left\\{ 2\\gamma(\\mathbf{h};\\boldsymbol{\\theta}):\\boldsymbol{\\theta}\\in \\Theta \\right\\}\\), donde \\(2\\gamma(\\mathbf{h};\\boldsymbol{\\theta})\\) es un variograma válido en \\(\\mathbb{R}^{d}\\) (normalmente isotrópico), es la familia parametrizada de variogramas escogida. Se trata de encontrar el mejor elemento de \\(P\\), para lo que se han propuesto diversos criterios de bondad de ajuste (ver p.e. Cressie, 1993, Sección 2.6). Entre ellos hay que destacar los basados en mínimos cuadrados y en máxima verosimilitud, descritos a continuación. 3.3.1 Estimación por mínimos cuadrados Supongamos que \\(2\\gamma(\\mathbf{h};\\boldsymbol{\\theta}_{0})\\) es el variograma teórico y que \\(\\hat{\\gamma}_{i} =\\hat{\\gamma}(\\mathbf{h}_{i})\\), \\(i = 1,\\ldots,K\\), son las estimaciones del semivariograma obtenidas utilizando algún tipo de estimador piloto (p.e. alguno de los mostrados en la Sección 4.1.1). Normalmente, siguiendo las recomendaciones sugeridas por Journel y Huijbregts (1978, p. 194), solamente se consideran en el ajuste saltos menores o iguales que la mitad del máximo salto (i.e. \\(\\left\\| \\mathbf{h}_{i} \\right\\| \\leq \\frac{1}{2} \\max \\left\\{ \\left\\| \\mathbf{s}_{k} -\\mathbf{s}_{l} \\right\\| \\right\\}\\)); y, si se utiliza el estimador empírico (o uno similar), de forma que el número de aportaciones a cada estimación sea por lo menos de treinta (i.e. \\(\\left| N(\\mathbf{h}_{i})\\right| \\geq 30\\)). Habitualmente (e.g. Cressie, 1993, p. 96-97) la estimación por mínimos cuadrados de \\(\\boldsymbol{\\theta}_{0}\\) se obtiene al minimizar: \\[\\begin{equation} \\left( \\hat{\\boldsymbol{\\gamma}} - \\boldsymbol{\\gamma}(\\boldsymbol{\\theta})\\right)^{\\top } \\mathbf{V}(\\boldsymbol{\\theta})\\left( \\hat{\\boldsymbol{\\gamma}} - \\boldsymbol{\\gamma}(\\boldsymbol{\\theta})\\right), \\tag{3.3} \\end{equation}\\] siendo \\(\\hat{\\boldsymbol{\\gamma}} =(\\hat{\\gamma}(\\mathbf{h}_1),\\ldots,\\hat{\\gamma} (\\mathbf{h}_{K}))^\\top\\), \\(\\boldsymbol{\\gamma}(\\boldsymbol{\\theta})=(\\gamma(\\mathbf{h}_1 ;\\boldsymbol{\\theta}),\\ldots,\\gamma(\\mathbf{h}_{K} ;\\boldsymbol{\\theta}))^\\top\\) y \\(\\mathbf{V}(\\boldsymbol{\\theta})\\) una matriz \\(K\\times K\\) semidefinida positiva que puede depender de \\(\\boldsymbol{\\theta}\\), considerando alguno de los siguientes casos: Mínimos cuadrados ordinarios (OLS): \\(\\mathbf{V}(\\boldsymbol{\\theta}) = \\mathbf{I}_{K}\\), la matriz identidad \\(K\\times K\\). Mínimos cuadrados ponderados (WLS): \\(\\mathbf{V}(\\boldsymbol{\\theta}) = \\text{diag}(w_1 (\\boldsymbol{\\theta}),\\ldots,w_{K}(\\boldsymbol{\\theta}))\\), con \\(w_{i}(\\boldsymbol{\\theta})\\geq 0\\), \\(i=1,\\ldots,K\\). Normalmente se suele tomar estos pesos inversamente proporcionales a \\(Var(\\hat{\\gamma}(\\mathbf{h}_{i}))\\). Mínimos cuadrados generalizados (GLS): \\(\\mathbf{V}(\\boldsymbol{\\theta})=\\Sigma_{\\hat{\\boldsymbol{\\gamma}}} (\\boldsymbol{\\theta})^{-1}\\), la inversa de la matriz de covarianzas (asintótica) de \\(\\hat{\\boldsymbol{\\gamma}}\\) obtenida suponiendo que el variograma teórico es \\(2\\gamma(\\mathbf{h};\\boldsymbol{\\theta})\\). Es importante señalar que al utilizar el criterio GLS el cálculo de la matriz de covarianzas \\(\\Sigma_{\\hat{\\boldsymbol{\\gamma}}} (\\boldsymbol{\\theta})\\) generalmente no resulta fácil (por ejemplo en Cressie 1993, p. 96, se tienen las expresiones para el estimador empírico y el estimador robusto, suponiendo normalidad). Esto produce que la minimización de la función objetivo (3.3) sea computacionalmente prohibitiva en muchos casos. El método de mínimos cuadrados ponderados puede verse como un compromiso entre la eficiencia del método de GLS y la simplicidad del método de OLS. Además, suponiendo normalidad y que el variograma teórico es \\(2\\gamma(\\mathbf{h};\\boldsymbol{\\theta})\\), Cressie (1985) probó que: \\[Var(\\hat{\\gamma}(\\mathbf{h}_{i}))\\simeq 2\\dfrac{\\gamma(\\mathbf{h}_{i} ;\\boldsymbol{\\theta})^2 }{\\left| N(\\mathbf{h}_{i})\\right| },\\] en el caso del estimador empírico; y para el estimador robusto: \\[Var(\\tilde{\\gamma}(\\mathbf{h}_{i}))\\simeq 2.885\\dfrac{\\gamma (\\mathbf{h}_{i} ;\\boldsymbol{\\theta})^2 }{\\left| N(\\mathbf{h}_{i})\\right| },\\] siendo esta aproximación incluso mejor que en el caso anterior. Proponiendo en estos casos la minimización de: \\[\\sum\\limits_{i=1}^{K} w_{i}(\\boldsymbol{\\theta}) \\left( \\hat{\\gamma}(\\mathbf{h}_{i}) - \\gamma(\\mathbf{h}_{i};\\boldsymbol{\\theta}) \\right)^2,\\] siendo \\(w_{i}(\\boldsymbol{\\theta}) = \\left| N(\\mathbf{h}_{i})\\right| /\\gamma(\\mathbf{h}_{i} ;\\boldsymbol{\\theta})^2\\), como aproximación al criterio WLS. Estos métodos de ajuste tiene unas propiedades interesantes, cuanto mayor sea \\(\\left| N(\\mathbf{h}_{i})\\right|\\) mayor peso recibe el residuo en el salto \\(\\mathbf{h}_{i}\\) y además, cuanto más pequeño sea el valor del variograma teórico mayor peso recibe también el residuo correspondiente. Por este motivo, los saltos próximos al origen típicamente reciben mayor peso con lo que se consigue un buen ajuste del modelo de variograma cerca del origen (esto es especialmente importante; ver p.e. Stein, 1988, y comentarios en la Sección 4.X). Adicionalmente estos métodos pueden ser implementados fácilmente en la práctica (de forma similar al OLS). Aunque para obtener las expresiones (o aproximaciones) de las varianzas y covarianzas de las estimaciones piloto se supone habitualmente que la distribución de los datos es normal, se puede probar fácilmente que los procedimientos de ajuste obtenidos son también válidos para el caso de datos normales transformados (ver p.e. Cressie, 1993, p. 98). Esta es una de las principales ventajas de los métodos WLS o GLS frente a otras alternativas (como los métodos basados en máxima verosimilitud); como utilizan solamente la estructura de segundo orden (asintótica) del estimador del variograma, no es necesario hacer suposiciones sobre la distribución completa de los datos13. Como comentario final, en la función objetivo (3.3) de los criterios WLS y GLS anteriores, la matriz de pesos utilizada en el ajuste \\(\\mathbf{V}(\\boldsymbol{\\theta})\\) depende también del parámetro sobre el que se realiza la minimización (y al minimizar (3.3) en cierto sentido se están maximizando también las varianzas), por lo que puede ser preferible utilizar un algoritmo iterativo. Por ejemplo comenzar con pesos OLS (o WLS con \\(w_{i} = \\left| N(\\mathbf{h}_{i})\\right| / \\| \\mathbf{h}_{i} \\|^2\\)) y posteriormente en cada etapa \\(k\\) obtener una nueva aproximación \\(\\hat{\\boldsymbol{\\theta}}_{0}^{(k)}\\) al minimizar: \\[\\left( \\hat{\\boldsymbol{\\gamma}} - \\boldsymbol{\\gamma}(\\boldsymbol{\\theta})\\right)^{\\top } \\mathbf{V}(\\hat{\\boldsymbol{\\theta}}_{0}^{(k-1)})\\left( \\hat{\\boldsymbol{\\gamma}} - \\boldsymbol{\\gamma}(\\boldsymbol{\\theta})\\right),\\] repitiendo este proceso hasta convergencia (realmente muchos de los algoritmos diseñados para el ajuste por mínimos cuadrados proceden de esta forma). En gstat el ajuste OLS y WLS se realiza mediante la función: fit.variogram(object, model, fit.sills = TRUE, fit.ranges = TRUE, fit.method = 7, fit.kappa = FALSE, ...) object: semivariograma empírico, obtenido con la función variogram(). model: modelo de semivariograma, generado con la función vgm(). fit.sills, fit.ranges, fit.kappa: determinan si se ajustan los correspondientes parámetros (TRUE) o se mantienen fijos (FALSE). fit.method: selección de los pesos en el criterio WLS. fit.method = 6: \\(w_{i} = 1\\), OLS. fit.method = 1: \\(w_{i} = \\left| N(\\mathbf{h}_{i})\\right|\\). fit.method = 7: \\(w_{i} = \\left| N(\\mathbf{h}_{i})\\right| / \\| \\mathbf{h}_{i} \\|^2\\). fit.method = 2: \\(w_{i} = \\left| N(\\mathbf{h}_{i})\\right| /\\gamma(\\mathbf{h}_{i} ;\\boldsymbol{\\theta})^2\\). Los parámetros iniciales se fijan a los establecidos en model. Si alguno es desconocido (NA), le asigna un valor por defecto: el rango se establece a 1/3 de la distancia máxima del variograma empírico, al umbral parcial se le asigna el promedio de los últimos 5 valores del variograma empírico, y el efecto nugget (siempre que haya sido establecido explícitamente con nugget = NA) se toma como la media de los tres primeros valores del variograma empírico. Como ejemplo, a continuación se ajusta un modelo exponencial al variograma empírico calculado en la Sección 3.1, mediante OLS y WLS con diferentes pesos: modelo &lt;- vgm(model = &quot;Exp&quot;, nugget = NA) # Valores iniciales por defecto, incluyendo nugget # modelo &lt;- vgm(psill = 0.6, model = &quot;Exp&quot;, range = 0.2, nugget = 0.0) # Valores iniciales fit.ols &lt;- fit.variogram(vario, model = modelo, fit.method = 6) # fit.npairs &lt;- fit.variogram(vario, model = modelo, fit.method = 1) # Warning: No convergence fit.npairs &lt;- fit.variogram(vario, model = fit.ols, fit.method = 1) ## Warning in fit.variogram(vario, model = fit.ols, fit.method = 1): No convergence ## after 200 iterations: try different initial values? fit.lin &lt;- fit.variogram(vario, model = modelo, fit.method = 7) fit.cressie &lt;- fit.variogram(vario, model = fit.lin, fit.method = 2) # Representar: # Cuidado con plot.variogramModel() si se pretende añadir elementos plot(vario$dist, vario$gamma, xlab = &quot;distance&quot;, ylab = &quot;semivariance&quot;, pch = 19, ylim = c(0, 1)) lines(variogramLine(fit.ols, maxdist = 0.6), lty = 2) lines(variogramLine(fit.npairs, maxdist = 0.6), lty = 3) lines(variogramLine(fit.lin, maxdist = 0.6), lty = 4) lines(variogramLine(fit.cressie, maxdist = 0.6)) legend(&quot;bottomright&quot;, c(&quot;ols&quot;, &quot;npairs&quot;, &quot;default (linear)&quot;, &quot;cressie&quot;), lty = c(2, 3, 4, 1)) # Parámetros estimados: fit.cressie ## model psill range ## 1 Nug 0.13495 0.0000000 ## 2 Exp 1.15982 0.6403818 # Error ajuste attr(fit.cressie, &quot;SSErr&quot;) ## [1] 52.83535 En gstat el ajuste GLS se podría realizar mediante la función: fit.variogram.gls(formula, data, model, maxiter = 30, eps = .01, trace = TRUE, ignoreInitial = TRUE, cutoff = Inf, plot = FALSE) Sin embargo, actualmente solo admite datos tipo Spatial* del paquete sp y además es habitual que aparezcan problemas computacionales, por lo que no se recomendaría su uso. fit.variogram.gls(z ~ 1, as(datos, &quot;Spatial&quot;), modelo, maxiter = 2, cutoff = 0.6, plot = TRUE) # Error in if (any(model$range &lt; 0)) { : missing value where TRUE/FALSE needed 3.3.2 Modelado del variograma en procesos no estacionarios Como ya se comentó en la introducción de este capítulo, si no se puede asumir que la tendencia es constante no es apropiado utilizar directamente los estimadores del semivariograma mostrados en la Sección 3.1. Por ejemplo, considerando el modelo lineal de la Sección 1.2.1 (el modelo del kriging universal, Sección 4.X), tendríamos que: \\[E(Z(\\mathbf{s}_1)-Z(\\mathbf{s}_{2}))^2 =2\\gamma(\\mathbf{s}_1 -\\mathbf{s}_{2}) + \\left( \\sum\\limits_{j=0}^{p}\\beta_{j} \\left( X_{j} (\\mathbf{s}_1)-X_{j}(\\mathbf{s}_{2})\\right) \\right)^2.\\] El procedimiento habitual en geoestadística es eliminar la tendencia y estimar el variograma a partir de los residuos. Como ejemplo consideraremos los datos del acuífero Wolfcamp: load(&quot;datos/aquifer.RData&quot;) library(sf) aquifer$head &lt;- aquifer$head/100 # en cientos de pies aquifer_sf &lt;- st_as_sf(aquifer, coords = c(&quot;lon&quot;, &quot;lat&quot;), remove = FALSE, agr = &quot;constant&quot;) # maxlag &lt;- 0.5*sqrt(sum(diff(matrix(st_bbox(aquifer_sf), nrow = 2, byrow = TRUE))^2)) vario.est &lt;- variogram(head ~ 1, aquifer_sf, cutoff = 150) vario.trend &lt;- variogram(head ~ lon + lat, aquifer_sf, cutoff = 150) oldpar &lt;- par(mfrow = c(1, 2)) # plot(vario.est) # no compatible con mfrow with(vario.est, plot(dist, gamma, xlab = &quot;distance&quot;, ylab = &quot;semivariance&quot;)) # plot(vario.trend) with(vario.trend, plot(dist, gamma, xlab = &quot;distance&quot;, ylab = &quot;semivariance&quot;)) par(oldpar) El ajuste por WLS se puede realizar también con la función fit.variogram(): # modelo &lt;- vgm(psill = 3, model = &quot;Sph&quot;, range = 75, nugget = 0) modelo &lt;- vgm(model = &quot;Sph&quot;, nugget = NA) # Valores iniciales por defecto fit.trend &lt;- fit.variogram(vario.trend, modelo, fit.method = 2) fit.trend ## model psill range ## 1 Nug 1.095133 0.00000 ## 2 Sph 3.044034 63.39438 # Cuidado con plot.variogramModel() si se pretende añadir elementos # plot(fit.trend, cutoff = 150, ylim = c(0, 4.5)) # with(vario.trend, points(dist, gamma)) with(vario.trend, plot(dist, gamma, xlab = &quot;distance&quot;, ylab = &quot;semivariance&quot;, ylim = c(0, 5))) lines(variogramLine(fit.trend, maxdist = 150)) Si no se puede asumir que la tendencia es constante, para poder estimarla de forma eficiente sería necesario conocer la dependencia (i.e. conocer \\(\\gamma(\\cdot)\\)), que dependería a su vez de la estimación de la tendencia. Para solventar este problema circular Neuman y Jacobson (1984) propusieron una aproximación iterativa, empezar con el estimador OLS de \\(?\\), estimar el variograma a partir de los residuos, ajustar un modelo de variograma válido, calcular el estimador GLS basado en el modelo ajustado y así sucesivamente hasta convergencia. En la práctica este procedimiento suele converger en pocas iteraciones (normalmente menos de 5). En el paquete gstat solo se realiza una iteración (se reestimará la tendencia empleando GLS al calcular las predicciones kriging). Función gls() del paquete nlme. gls(model, data, correlation, weights, method, control, ...) Problema sesgo variograma Otra alternativa sería asumir normalidad y estimar ambos componentes de forma conjunta empleando alguno de los métodos basados en máxima verosimilitud descritos en la Sección 3.3.3. 3.3.3 Estimación por máxima verosimilitud 3.3.4 Comentarios sobre los distintos métodos La distribución y eficiencia asintótica de los estimadores mínimo cuadráticos ha sido estudiada por Lahiri et al. (2003), demostrando su consistencia y normalidad asintótica bajo condiciones muy generales. "],["kriging.html", "Capítulo 4 Predicción Kriging", " Capítulo 4 Predicción Kriging En preparación En este capítulo se comentan brevemente los métodos más conocidos de predicción espacial denominados métodos kriging14 (ver Sección 1.2.1 para un resumen del origen de esta terminología), centrándonos únicamente en el caso de predicción lineal puntual univariante (el caso multivariante se trata en el Capítulo 5). Una revisión más completa de estos métodos se tiene por ejemplo en Cressie (1993, Capítulo 3 y secciones 5.1, 5.4 y 5.9.1) o Chilès y Delfiner (1999, capítulos 3, 4 y 6). Podríamos definir los métodos kriging como algoritmos de predicción de mínimo error en media cuadrática que tienen en cuenta la estructura de segundo orden del proceso. "],["introducción.html", "4.1 Introducción", " 4.1 Introducción Si denotamos por \\(\\mathbf{Z}=\\left( Z(\\mathbf{s}_{1} ), \\ldots, z(\\mathbf{s}_{n} )\\right)^\\top\\) valores observados del proceso, los distintos métodos kriging proporcionan un predictor \\(p(\\mathbf{Z},\\mathbf{s}_{0} )\\) de \\(Z(\\mathbf{s}_{0} )\\) verificando que: es lineal: \\[p(\\mathbf{Z},\\mathbf{s}_{0} )=\\sum\\limits_{i=1}^{n}\\lambda_{i} Z(\\mathbf{s}_{i} ) +\\lambda_{0},\\] es uniformemente insesgado, para cualquier \\(\\mu(\\cdot)\\): \\[E(p(\\mathbf{Z},\\mathbf{s}_{0} ))=\\mu(\\mathbf{s}_{0} ),\\] y minimiza el error en media cuadrática (e.m.c.) de predicción15: \\[E\\left( \\left( p(\\mathbf{Z},\\mathbf{s}_{0} )-Z(\\mathbf{s}_{0} )\\right)^{\\text{2} } \\right),\\] (al hablar de predicción óptima nos referiremos a que se verifican estas dos últimas condiciones). Dependiendo de las suposiciones acerca de la función de tendencia \\(\\mu(\\cdot)\\), se distingue principalmente entre tres métodos kriging: Kriging simple (KS): se supone que la media es conocida (algunos autores suponen también que es constante o incluso cero). Además se asume que el covariograma existe y es conocido. Kriging ordinario (KO): se supone que la media es constante (i.e. \\(E(Z(\\mathbf{s}))=\\mu ,\\forall \\mathbf{s}\\in D\\)) y desconocida. Además se asume que por lo menos existe el variograma y es conocido. Kriging universal (KU; también denominado kriging con modelo de tendencia): se supone que la media es desconocida y no constante, pero que es una combinación lineal (desconocida) de \\(p+1\\) funciones (o variables explicativas) conocidas \\(\\left\\{ x_j(\\cdot) : j = 0, \\ldots, p \\right\\}\\): \\[\\mu(\\mathbf{s})=\\sum\\limits_{j=0}^{p}x_j (\\mathbf{s})\\beta_j\\] donde \\(\\boldsymbol{\\beta} = (\\beta_{0}, \\ldots, \\beta_{p} )^\\top \\in \\mathbb{R}^{p+1}\\) es un vector desconocido. Se asume también que por lo menos existe el variograma y es conocido16. Por simplicidad el kriging ordinario se tratará en este capítulo como un caso particular del kriging universal (aunque en la práctica se suele pensar en el KO como un método distinto al KU, principalmente por ciertos inconvenientes que presenta este último; ver Sección 4.X.X). Como es bien sabido, en el caso de normalidad el predictor óptimo (tomando como función de pérdidas el error cuadrático) es lineal y va a coincidir con los predictores kriging. Pero si el proceso no es normal no tiene porque serlo, lo que ha motivado el desarrollo de métodos kriging no lineales (ver p.e. Rivoirard, 1994) y del kriging trans-normal (ver sección 4.X). Siempre que una de las funciones explicativas sea idénticamente 1, p.e. \\(x_{0}(\\cdot) \\equiv 1\\), en caso contrario las ecuaciones kriging sólo pueden expresarse en función del covariograma. "],["ksimple.html", "4.2 Kriging con media conocida: kriging simple", " 4.2 Kriging con media conocida: kriging simple "],["kuniversal.html", "4.3 Kriging con media desconocida: kriging universal y kriging residual", " 4.3 Kriging con media desconocida: kriging universal y kriging residual "],["consideraciones-kriging.html", "4.4 Consideraciones acerca de los métodos kriging", " 4.4 Consideraciones acerca de los métodos kriging "],["multivar.html", "Capítulo 5 Procesos espaciales multivariantes", " Capítulo 5 Procesos espaciales multivariantes En preparación Si \\(\\left\\{ Z_{j}(\\mathbf{s}):j=1, \\ldots, k;\\mathbf{s}\\in D\\right\\}\\) son \\(k\\) procesos espaciales univariantes (y que se suponen en principio interdependientes), el vector \\[\\mathbf{Z}(\\mathbf{s})=(Z_{1}(\\mathbf{s}), \\ldots, Z_{k}(\\mathbf{s}))^\\top\\] lo denominaremos proceso espacial multivariante (también se denomina proceso espacial vectorial, campo vectorial espacial o vector regionalizado). "],["esp-temp.html", "Capítulo 6 Procesos espaciales espacio-temporales", " Capítulo 6 Procesos espaciales espacio-temporales En preparación Como ya se comentó en el Capítulo 1 se puede pensar en un procesos espacio-temporal como un caso particular de un proceso espacial en el que una de las componentes es el tiempo. Sin embargo, para enfatizar el carácter temporal, se utilizará una notación de la forma: \\[\\left\\{ Z(\\mathbf{s},t):(\\mathbf{s},t)\\in D\\times T\\right\\}\\] donde \\(D\\times T\\subset \\mathbb{R} ^{d} \\times \\mathbb{R}^{+,0}\\), para referirse a un proceso espacio-temporal. En algunos casos los procesos espacio-temporales son modelados también como procesos espaciales multivariantes (e.g. Egbert y Lettenmaier, 1986; Kyriakidis y Journel, 1999). Por ejemplo, se puede considerar una representación de la forma: \\[Z(\\mathbf{s},t)=\\mathbf{Z}(\\mathbf{s})=(Z_{1} (\\mathbf{s}), \\ldots,Z_{k} ( \\mathbf{s}))^\\top,\\] donde \\[Z_{i} (\\mathbf{s})=Z(\\mathbf{s},t_{i} ),\\ i=1, \\ldots,k.\\] O también: \\[Z(\\mathbf{s},t) = \\mathbf{Z}(t) = \\left(Z_{1}(t), \\ldots, Z_{n}(t) \\right)^\\top,\\] siendo \\[Z_{j} (t)=Z(\\mathbf{s}_{j} ,t),\\ j=1, \\ldots,n.\\] Uno de los principales problemas al utilizar estas aproximaciones es que, utilizando los modelos geoestadísticos tradicionales, no es posible la predicción en todas las posiciones espacio-temporales sin algún tipo de modelado adicional. Por ejemplo, utilizando la representación y los métodos geoestadísticos de predicción espacial multivariante, se pueden obtener en principio superficies de predicción solamente en los k instantes temporales \\(t_{i} ,\\ i=1, \\ldots, k\\), y no es posible la interpolación temporal sin modelado adicional (ver Sección 5.3.5). "],["intro-sp.html", "A Introducción al paquete sp", " A Introducción al paquete sp El paquete sp [Classes and methods for spatial data; E. J. Pebesma y Bivand (2005)] implementa objetos y métodos para datos espaciales Introducción, para más detalles ver Bivand et al. (2013) https://www.maths.lancs.ac.uk/~rowlings/Teaching/UseR2012/cheatsheet.html References Bivand, R. S., Pebesma, E., y Gómez-Rubio, V. (2013). Applied Spatial Data Analysis with R (Second). Springer. http://www.asdar-book.org/ Pebesma, E. J., y Bivand, R. S. (2005). Classes and methods for spatial data in R. R News, 5(2), 9-13. https://CRAN.R-project.org/doc/Rnews/ "],["tipos-de-objetos.html", "A.1 Tipos de objetos", " A.1 Tipos de objetos # Librería sp:classes and methods for spatial data library(sp) # install.packages(&#39;sp&#39;) # Tipos de objetos getClass(&quot;Spatial&quot;) ## Class &quot;Spatial&quot; [package &quot;sp&quot;] ## ## Slots: ## ## Name: bbox proj4string ## Class: matrix CRS ## ## Known Subclasses: ## Class &quot;SpatialPoints&quot;, directly ## Class &quot;SpatialMultiPoints&quot;, directly ## Class &quot;SpatialGrid&quot;, directly ## Class &quot;SpatialLines&quot;, directly ## Class &quot;SpatialPolygons&quot;, directly ## Class &quot;SpatialPointsDataFrame&quot;, by class &quot;SpatialPoints&quot;, distance 2 ## Class &quot;SpatialPixels&quot;, by class &quot;SpatialPoints&quot;, distance 2 ## Class &quot;SpatialMultiPointsDataFrame&quot;, by class &quot;SpatialMultiPoints&quot;, distance 2 ## Class &quot;SpatialGridDataFrame&quot;, by class &quot;SpatialGrid&quot;, distance 2 ## Class &quot;SpatialLinesDataFrame&quot;, by class &quot;SpatialLines&quot;, distance 2 ## Class &quot;SpatialPixelsDataFrame&quot;, by class &quot;SpatialPoints&quot;, distance 3 ## Class &quot;SpatialPolygonsDataFrame&quot;, by class &quot;SpatialPolygons&quot;, distance 2 Clases del tipo S4 (definicion formal con componentes denominadas slots) Tipo base: Spatial bbox (bounding box): matriz con los límites mínimo y máximo de las coordenadas (principalmente para representación gráfica; normalmente se genera automáticamente). proj4string: cadena de texto que define el sistema de coordenadas de referencia (realmente objeto tipo CRS, coordinate reference system) en formato PROJ.4. CRS(as.character(NA)) para indicar no disponible/faltante CRS(+proj=longlat) para coordenadas geográficas CRS(+proj=longlat +ellps=WGS84) estándar GPS (World Geodetic System of 1984) xbbox &lt;- matrix( c(0,0,1,1), ncol=2) colnames(xbbox) &lt;- c(&quot;min&quot;, &quot;max&quot;) # Normalmente la bbox se genera automáticamente al crear el objeto x &lt;- Spatial(xbbox, proj4string = CRS(as.character(NA))) x ## An object of class &quot;Spatial&quot; ## Slot &quot;bbox&quot;: ## min max ## [1,] 0 1 ## [2,] 0 1 ## ## Slot &quot;proj4string&quot;: ## CRS arguments: NA Los objetos son del tipo S4. Los componentes se denominan slots. Se acceden con la función slot() o el operador @. slot(x,&#39;bbox&#39;) ## min max ## [1,] 0 1 ## [2,] 0 1 x@bbox ### en s4 se pone @ en vez de $. ## min max ## [1,] 0 1 ## [2,] 0 1 El paquete sp dispone también de funciones para acceder/establecer los componentes: bbox(x) ## min max ## [1,] 0 1 ## [2,] 0 1 proj4string(x) &lt;- CRS(&quot;+proj=longlat +ellps=WGS84&quot;) # Importante A.1.1 SpatialPoints y SpatialPointsDataFrame Tipo SpatialPoints Slots: coords, bbox, proj4string Objeto de datos básico para procesos puntuales. Tipo SpatialPointsDataFrame Slots: data, coords.nrs, coords, bbox, proj4string Objeto de datos básico para procesos geoestadísticos (y procesos puntuales marcados). A.1.1.1 Ejemplo SpatialPoints load(&quot;datos/caballa.galicia.RData&quot;) str(caballa.galicia) # data.frame(attr(caballa.galicia, &quot;variable.labels&quot;)) ## &#39;data.frame&#39;: 676 obs. of 12 variables: ## $ id : Factor w/ 31 levels &quot;A1&quot;,&quot;A2&quot;,&quot;B1&quot;,..: 17 17 19 19 19 21 21 23 23 23 ... ## $ x : num -9.4 -9.44 -9.44 -9.4 -9.47 ... ## $ y : num 43 43 43 43 42.8 ... ## $ fecha : num 1.32e+10 1.32e+10 1.32e+10 1.32e+10 1.32e+10 ... ## $ semana : num 7 7 7 7 7 7 8 8 8 8 ... ## $ mes : num 2 2 2 2 2 2 2 2 2 2 ... ## $ ano : num 2001 2001 2001 2001 2001 ... ## $ cpue : num 18 240 240 18 118 ... ## $ chl_a : num NA NA 7.08 7.08 7.08 ... ## $ sust_amar: num NA NA 0.356 0.356 0.356 ... ## $ sst : num 14.2 14.2 16 16 16 16.1 16 15.9 15.9 15.9 ... ## $ lcpue : num 2.89 5.48 5.48 2.89 4.77 ... ## - attr(*, &quot;variable.labels&quot;)= Named chr [1:12] &quot;Cuadricula &quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## ..- attr(*, &quot;names&quot;)= chr [1:12] &quot;id&quot; &quot;x&quot; &quot;y&quot; &quot;fecha&quot; ... ## - attr(*, &quot;codepage&quot;)= int 1252 plot(y~x, data = caballa.galicia) spt &lt;- SpatialPoints(caballa.galicia[,c(&quot;x&quot;,&quot;y&quot;)], proj4string = CRS(&quot;+proj=longlat +ellps=WGS84&quot;)) summary(spt) ## Object of class SpatialPoints ## Coordinates: ## min max ## x -9.56538 -8.030065 ## y 41.86240 44.010800 ## Is projected: FALSE ## proj4string : [+proj=longlat +ellps=WGS84 +no_defs] ## Number of points: 676 str(spt) ## Formal class &#39;SpatialPoints&#39; [package &quot;sp&quot;] with 3 slots ## ..@ coords : num [1:676, 1:2] -9.4 -9.44 -9.44 -9.4 -9.47 ... ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : chr [1:676] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## .. .. ..$ : chr [1:2] &quot;x&quot; &quot;y&quot; ## ..@ bbox : num [1:2, 1:2] -9.57 41.86 -8.03 44.01 ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : chr [1:2] &quot;x&quot; &quot;y&quot; ## .. .. ..$ : chr [1:2] &quot;min&quot; &quot;max&quot; ## ..@ proj4string:Formal class &#39;CRS&#39; [package &quot;sp&quot;] with 1 slot ## .. .. ..@ projargs: chr &quot;+proj=longlat +ellps=WGS84 +no_defs&quot; ## .. .. ..$ comment: chr &quot;GEOGCRS[\\&quot;unknown\\&quot;,\\n DATUM[\\&quot;Unknown based on WGS84 ellipsoid\\&quot;,\\n ELLIPSOID[\\&quot;WGS 84\\&quot;,6378137,298&quot;| __truncated__ Hay muchos métodos (funciones genéricas) implementados para objetos sp: # plot(spt) plot(spt, axes=TRUE) A.1.1.2 Ejemplo SpatialPointsDataFrame Importante (para preparar datos): sdf1 &lt;- SpatialPointsDataFrame(caballa.galicia[,c(2,3)], caballa.galicia[,-c(2,3)], proj4string = CRS(&quot;+proj=longlat +ellps=WGS84&quot;)) str(sdf1) ## Formal class &#39;SpatialPointsDataFrame&#39; [package &quot;sp&quot;] with 5 slots ## ..@ data :&#39;data.frame&#39;: 676 obs. of 10 variables: ## .. ..$ id : Factor w/ 31 levels &quot;A1&quot;,&quot;A2&quot;,&quot;B1&quot;,..: 17 17 19 19 19 21 21 23 23 23 ... ## .. ..$ fecha : num [1:676] 1.32e+10 1.32e+10 1.32e+10 1.32e+10 1.32e+10 ... ## .. ..$ semana : num [1:676] 7 7 7 7 7 7 8 8 8 8 ... ## .. ..$ mes : num [1:676] 2 2 2 2 2 2 2 2 2 2 ... ## .. ..$ ano : num [1:676] 2001 2001 2001 2001 2001 ... ## .. ..$ cpue : num [1:676] 18 240 240 18 118 ... ## .. ..$ chl_a : num [1:676] NA NA 7.08 7.08 7.08 ... ## .. ..$ sust_amar: num [1:676] NA NA 0.356 0.356 0.356 ... ## .. ..$ sst : num [1:676] 14.2 14.2 16 16 16 16.1 16 15.9 15.9 15.9 ... ## .. ..$ lcpue : num [1:676] 2.89 5.48 5.48 2.89 4.77 ... ## ..@ coords.nrs : num(0) ## ..@ coords : num [1:676, 1:2] -9.4 -9.44 -9.44 -9.4 -9.47 ... ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : chr [1:676] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## .. .. ..$ : chr [1:2] &quot;x&quot; &quot;y&quot; ## ..@ bbox : num [1:2, 1:2] -9.57 41.86 -8.03 44.01 ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : chr [1:2] &quot;x&quot; &quot;y&quot; ## .. .. ..$ : chr [1:2] &quot;min&quot; &quot;max&quot; ## ..@ proj4string:Formal class &#39;CRS&#39; [package &quot;sp&quot;] with 1 slot ## .. .. ..@ projargs: chr &quot;+proj=longlat +ellps=WGS84 +no_defs&quot; ## .. .. ..$ comment: chr &quot;GEOGCRS[\\&quot;unknown\\&quot;,\\n DATUM[\\&quot;Unknown based on WGS84 ellipsoid\\&quot;,\\n ELLIPSOID[\\&quot;WGS 84\\&quot;,6378137,298&quot;| __truncated__ Una alernativa normalmente preferible es modificar directamente el data.frame: sdf &lt;- caballa.galicia coordinates(sdf) &lt;- c(&quot;x&quot;, &quot;y&quot;) # Recomendación proj4string(sdf) &lt;- CRS(&quot;+proj=longlat +ellps=WGS84&quot;) # También sdf@proj4string &lt;- CRS(&quot;+proj=longlat +ellps=WGS84&quot;) str(sdf) ## Formal class &#39;SpatialPointsDataFrame&#39; [package &quot;sp&quot;] with 5 slots ## ..@ data :&#39;data.frame&#39;: 676 obs. of 10 variables: ## .. ..$ id : Factor w/ 31 levels &quot;A1&quot;,&quot;A2&quot;,&quot;B1&quot;,..: 17 17 19 19 19 21 21 23 23 23 ... ## .. ..$ fecha : num [1:676] 1.32e+10 1.32e+10 1.32e+10 1.32e+10 1.32e+10 ... ## .. ..$ semana : num [1:676] 7 7 7 7 7 7 8 8 8 8 ... ## .. ..$ mes : num [1:676] 2 2 2 2 2 2 2 2 2 2 ... ## .. ..$ ano : num [1:676] 2001 2001 2001 2001 2001 ... ## .. ..$ cpue : num [1:676] 18 240 240 18 118 ... ## .. ..$ chl_a : num [1:676] NA NA 7.08 7.08 7.08 ... ## .. ..$ sust_amar: num [1:676] NA NA 0.356 0.356 0.356 ... ## .. ..$ sst : num [1:676] 14.2 14.2 16 16 16 16.1 16 15.9 15.9 15.9 ... ## .. ..$ lcpue : num [1:676] 2.89 5.48 5.48 2.89 4.77 ... ## ..@ coords.nrs : int [1:2] 2 3 ## ..@ coords : num [1:676, 1:2] -9.4 -9.44 -9.44 -9.4 -9.47 ... ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : chr [1:676] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## .. .. ..$ : chr [1:2] &quot;x&quot; &quot;y&quot; ## ..@ bbox : num [1:2, 1:2] -9.57 41.86 -8.03 44.01 ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : chr [1:2] &quot;x&quot; &quot;y&quot; ## .. .. ..$ : chr [1:2] &quot;min&quot; &quot;max&quot; ## ..@ proj4string:Formal class &#39;CRS&#39; [package &quot;sp&quot;] with 1 slot ## .. .. ..@ projargs: chr &quot;+proj=longlat +ellps=WGS84 +no_defs&quot; ## .. .. ..$ comment: chr &quot;GEOGCRS[\\&quot;unknown\\&quot;,\\n DATUM[\\&quot;Unknown based on WGS84 ellipsoid\\&quot;,\\n ELLIPSOID[\\&quot;WGS 84\\&quot;,6378137,298&quot;| __truncated__ Operaciones como en un data.frame. names(sdf) ## [1] &quot;id&quot; &quot;fecha&quot; &quot;semana&quot; &quot;mes&quot; &quot;ano&quot; &quot;cpue&quot; ## [7] &quot;chl_a&quot; &quot;sust_amar&quot; &quot;sst&quot; &quot;lcpue&quot; sdf$id # Equivalente a sdf@data$id ## [1] E2 E2 F2 F2 F2 G2 G2 H1 H1 H1 I1 I1 I2 I2 J1 J1 J1 J1 J2 J2 J2 D1 E1 F1 F1 ## [26] G1 G2 H2 I2 I2 J1 J2 D1 E2 E2 F2 F1 F1 F1 F2 G1 G1 G2 G2 H2 I1 I1 I2 I2 I2 ## [51] J1 J1 J2 E2 F1 F1 G1 G2 H1 H2 H2 I1 I1 I1 I1 I2 I2 I2 F1 F2 F2 G2 I1 I1 I1 ## [76] I1 I2 I2 I2 I2 J1 J1 E2 F2 F2 F2 F2 G2 G2 H3 I3 I3 I3 J3 J3 J3 F2 G2 H2 F2 ## [101] G2 G2 H2 I1 I1 I2 I2 J2 B2 B3 C2 C3 C3 E2 F2 F2 G2 H3 I3 B3 B3 C3 C3 C3 C4 ## [126] C4 C4 I2 I2 I3 J2 J2 H2 H2 H2 I2 I2 I2 E2 F2 F2 G2 B2 B3 B3 C3 C3 C3 C4 C4 ## [151] E1 F1 F1 F1 F2 G1 G1 G2 E1 F1 F2 G2 G2 H2 I2 I2 I2 J2 J2 A1 B2 B3 B3 B3 B4 ## [176] B4 C3 I2 I2 J2 J2 I2 J2 I2 J2 I3 J2 J3 A1 A2 A2 B3 B4 B4 B5 C2 C3 C3 C4 D2 ## [201] D3 F1 F2 C2 C2 C3 C3 C3 C4 C4 D4 H2 H2 H3 I3 B2 B3 C2 C2 C3 C3 C3 C3 C4 B2 ## [226] B3 C2 C3 C3 C3 C3 C4 C4 C4 B2 C2 C2 C3 C3 C3 C3 C4 C4 C4 H2 H2 I1 I2 I2 I1 ## [251] I2 I2 I2 I2 I3 J1 J2 J2 J2 J3 B2 B3 B3 B3 B3 C3 C3 C3 C3 C4 C4 C4 I2 I2 I3 ## [276] I3 J2 J2 J3 J3 B2 C3 C3 C4 C4 B2 B2 B3 B3 B3 C3 C3 C3 C4 C4 B2 B2 B3 C3 C3 ## [301] C3 C3 C4 D4 B2 B2 B3 C2 C2 C3 C3 C3 C3 C4 I2 J2 J2 J2 B2 B3 C2 C2 C3 C3 C4 ## [326] I3 J2 J2 J3 B3 B3 B3 B4 B4 C3 C4 C4 B2 B3 C3 C3 C3 C4 C4 B3 C3 C3 C4 C4 C4 ## [351] B3 B3 B3 B4 B4 C4 G2 H1 H2 H2 B3 B3 B4 C4 C4 H2 H2 I2 I2 H2 I2 J2 B3 B3 B4 ## [376] C3 C4 C4 D4 B3 C3 C3 C4 C4 C4 D4 D4 H2 I2 I2 J1 J2 D1 D2 D2 D2 D2 H2 I2 E2 ## [401] F2 F2 F2 E2 E2 F2 F2 E2 F2 F2 F2 G2 B2 B2 B3 B3 B3 C3 C3 C3 C4 C1 C2 C3 C3 ## [426] C4 D1 D2 D4 C1 C2 C2 C3 C3 C4 I2 I2 J1 J1 J2 J2 I3 H2 H3 I2 I2 I2 I2 I2 I3 ## [451] J1 J1 J1 J2 J2 J2 J2 H3 H3 I2 I3 I3 I3 I3 I3 J2 J2 J3 H3 H3 H3 I2 I2 I2 I3 ## [476] I3 I3 J2 J2 G3 G3 H2 H2 H2 H2 H2 H3 G3 H2 H2 H2 E1 F1 E1 F1 E1 F1 G2 H1 H2 ## [501] H2 H3 I3 C2 D1 D1 D1 D2 D2 D2 E2 E2 E2 F2 B1 B2 C2 C2 C3 D1 D1 D1 D2 E2 E2 ## [526] H2 I2 I2 I2 J1 J1 J1 J2 J2 H3 H3 I3 I3 I3 I3 J3 J3 H1 I1 H3 H3 I2 I2 I3 I3 ## [551] I3 I3 J2 J2 I2 I3 J2 H3 H3 I3 I3 I3 I3 J3 J3 H3 I3 I3 I3 J3 J3 H3 H3 I2 I3 ## [576] I3 I3 I3 J3 J3 H3 H3 I2 I3 I3 I3 J2 J2 J3 F1 F2 G2 G2 H1 H2 H2 F1 G1 G2 I1 ## [601] I2 I2 I2 J1 J1 J2 J2 J2 I2 I2 I2 I2 J2 J2 J2 J2 D1 D2 E2 E2 E2 F2 F2 G2 D1 ## [626] D1 D1 D1 D2 D2 E1 E2 E2 F1 G1 G2 G2 F1 G1 G1 G1 G2 G2 G1 G2 H3 I2 I3 I3 J2 ## [651] J2 J3 J3 H3 I3 I3 I3 I3 I3 J2 J3 J3 J3 J3 H3 I2 I3 I3 I3 I3 I3 I3 J3 J3 J3 ## [676] J3 ## 31 Levels: A1 A2 B1 B2 B3 B4 B5 C1 C2 C3 C4 D1 D2 D3 D4 E1 E2 F1 F2 G1 ... J3 plot(sdf, axes = TRUE) plot(sdf[sdf$id == &quot;J3&quot;, ], col = &quot;red&quot;, add = TRUE) Importante (para análisis descriptivo): summary(sdf[,c(&quot;cpue&quot;,&quot;lcpue&quot;)]) ## Object of class SpatialPointsDataFrame ## Coordinates: ## min max ## x -9.56538 -8.030065 ## y 41.86240 44.010800 ## Is projected: FALSE ## proj4string : [+proj=longlat +ellps=WGS84 +no_defs] ## Number of points: 676 ## Data attributes: ## cpue lcpue ## Min. : 0.1435 Min. :-1.9411 ## 1st Qu.: 1.9559 1st Qu.: 0.6708 ## Median : 5.8537 Median : 1.7671 ## Mean : 30.9208 Mean : 1.9087 ## 3rd Qu.: 19.5349 3rd Qu.: 2.9722 ## Max. :870.0000 Max. : 6.7685 hist(sdf$cpue) hist(sdf$lcpue) spplot(sdf, &quot;lcpue&quot;) A.1.2 SpatialLines y SpatialPolygons Tipo SpatialLines Basados en Line: coords Se combinan objetos Line en listas: lines, bbox, proj4string De utilidad principalmente para representaciones gráficas (y para generar polígonos). Tipo SpatialPolygons Basados en Polygon: labpt, area, hole, ringDir, coords(extiende Line de forma que la primera y la última línea es la misma). Se combinan objetos Polygon en listas: polygons, plotOrder, bbox, proj4string. De utilidad principalmente para representaciones gráficas (y overlay). Se extienden también a Spatial*DataFrame (slot data) SpatialPolygonsDataFrame: util para procesos reticulares. A.1.2.1 Ejemplo SpatialLines El fichero costa.galicia.txt contiene la costa de Galicia en formato Mapgen. Descargada del (difunto) Coastline Extractor library(maptools) # Utilidades para convertir datos entre diferentes formatos espaciales ## Checking rgeos availability: TRUE costa.galicia &lt;- MapGen2SL(&quot;datos/costa.galicia.txt&quot;, CRS(&quot;+proj=longlat +ellps=WGS84&quot;)) summary(costa.galicia) ## Object of class SpatialLines ## Coordinates: ## min max ## x -9.305495 -6.500147 ## y 41.500846 43.791944 ## Is projected: FALSE ## proj4string : [+proj=longlat +ellps=WGS84 +no_defs] plot(sdf, axes=TRUE) plot(costa.galicia, add=TRUE) A.1.2.2 Ejemplo SpatialPolygonsDataFrame Los objetos de este tipo se suelen crear a partir de objetos SpatialLines, pero hay que asegurarse de que definen adecuadamente un polígono. Objetos de este tipo se pueden descargar de GADM database of Global Administrative Areas. Contienen límites administrativos a disintos niveles, e.g.: ESP_adm0.rds límites España e islas ESP_adm1.rds límites Autonomías ESP_adm2.rds límites Provincias ESP_adm3.rds límites Comarcas ESP_adm4.rds límites Ayuntamientos NOTA: Se podrían descargar directamente desde R, e.g.: con &lt;- url(&#39;http://gadm.org/data/rda/ESP_adm1.rds&#39;) gadm &lt;- readRDS(con) close(con) Carga de un objeto gadm: gadm &lt;- readRDS(&quot;datos/ESP_adm1.rds&quot;) summary(gadm) ## Object of class SpatialPolygonsDataFrame ## Coordinates: ## min max ## x -18.16153 4.328195 ## y 27.63736 43.791527 ## Is projected: FALSE ## proj4string : ## [+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0] ## Data attributes: ## OBJECTID ID_0 ISO NAME_0 ## Min. : 1.00 Min. :215 Length:18 Length:18 ## 1st Qu.: 5.25 1st Qu.:215 Class :character Class :character ## Median : 9.50 Median :215 Mode :character Mode :character ## Mean : 9.50 Mean :215 ## 3rd Qu.:13.75 3rd Qu.:215 ## Max. :18.00 Max. :215 ## ## ID_1 NAME_1 HASC_1 CCN_1 ## Min. : 1.00 Length:18 Length:18 Min. : NA ## 1st Qu.: 5.25 Class :character Class :character 1st Qu.: NA ## Median : 9.50 Mode :character Mode :character Median : NA ## Mean : 9.50 Mean :NaN ## 3rd Qu.:13.75 3rd Qu.: NA ## Max. :18.00 Max. : NA ## NA&#39;s :18 ## CCA_1 TYPE_1 ENGTYPE_1 NL_NAME_1 ## Length:18 Length:18 Length:18 Length:18 ## Class :character Class :character Class :character Class :character ## Mode :character Mode :character Mode :character Mode :character ## ## ## ## ## VARNAME_1 ## Length:18 ## Class :character ## Mode :character ## ## ## ## plot(gadm) # Cuidado objeto muy grande: str(gadm) # Mejor emplear str(gadm, 3) Extraer autonomía de Galicia: names(gadm) ## [1] &quot;OBJECTID&quot; &quot;ID_0&quot; &quot;ISO&quot; &quot;NAME_0&quot; &quot;ID_1&quot; &quot;NAME_1&quot; ## [7] &quot;HASC_1&quot; &quot;CCN_1&quot; &quot;CCA_1&quot; &quot;TYPE_1&quot; &quot;ENGTYPE_1&quot; &quot;NL_NAME_1&quot; ## [13] &quot;VARNAME_1&quot; galicia &lt;- gadm[gadm$NAME_1 == &quot;Galicia&quot;, ] plot(galicia) Es preferible emplear este tipo de objetos a SpatialLines: plot(sdf, axes=TRUE) plot(galicia, add=TRUE) A.1.3 SpatialGrid y SpatialPixels Es habitual trabajar con datos espaciales en formato rejilla (grid) (e.g. predicciones en geoestadística): Rejilla (posiciones) definida por un objeto GridTopology: cellcentre.offset, cellsize, cells.dim Tipos SpatialGrid y SpatialPixels: grid, grid.index, coords, bbox, proj4string Se extienden también a Spatial*DataFrame (slot data) Los objetos SpatialGrid se corresponden con la rejilla completa: Los objetos SpatialPixels se corresponden con una rejilla incompleta coordscontiene todas las coordenadas (objetos equivalentes a SpatialPoints) grid.indexindices de la rejilla A.1.3.1 Ejemplo SpatialGrid Importante si se utiliza el paquete gstat xrange &lt;- c(-10, -7.5) yrange &lt;- c(42.25, 44) nx &lt;- 100 ny &lt;- 100 hx &lt;- diff(xrange)/(nx-1) hy &lt;- diff(yrange)/(ny-1) gridtop &lt;- GridTopology(cellcentre.offset = c(min(xrange), min(yrange)), cellsize = c(hx, hy), cells.dim = c(nx, ny)) spgrid &lt;- SpatialGrid(gridtop, proj4string = proj4string(gadm)) str(spgrid) ## Formal class &#39;SpatialGrid&#39; [package &quot;sp&quot;] with 3 slots ## ..@ grid :Formal class &#39;GridTopology&#39; [package &quot;sp&quot;] with 3 slots ## .. .. ..@ cellcentre.offset: num [1:2] -10 42.2 ## .. .. ..@ cellsize : num [1:2] 0.0253 0.0177 ## .. .. ..@ cells.dim : int [1:2] 100 100 ## ..@ bbox : num [1:2, 1:2] -10.01 42.24 -7.49 44.01 ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : NULL ## .. .. ..$ : chr [1:2] &quot;min&quot; &quot;max&quot; ## ..@ proj4string:Formal class &#39;CRS&#39; [package &quot;sp&quot;] with 1 slot ## .. .. ..@ projargs: chr &quot;+proj=longlat +datum=WGS84 +no_defs&quot; ## .. .. ..$ comment: chr &quot;GEOGCRS[\\&quot;unknown\\&quot;,\\n DATUM[\\&quot;World Geodetic System 1984\\&quot;,\\n ELLIPSOID[\\&quot;WGS 84\\&quot;,6378137,298.25722&quot;| __truncated__ plot(spgrid, axes = TRUE) plot(galicia, add = TRUE) A.1.3.2 Ejemplo SpatialPixels # over: combinación de objetos espaciales index &lt;- over(spgrid, as(galicia, &quot;SpatialPolygons&quot;)) sppix &lt;- as(spgrid, &quot;SpatialPixels&quot;)[is.na(index), ] str(sppix) ## Formal class &#39;SpatialPixels&#39; [package &quot;sp&quot;] with 5 slots ## ..@ grid :Formal class &#39;GridTopology&#39; [package &quot;sp&quot;] with 3 slots ## .. .. ..@ cellcentre.offset: num [1:2] -10 42.2 ## .. .. ..@ cellsize : num [1:2] 0.0253 0.0177 ## .. .. ..@ cells.dim : int [1:2] 100 100 ## ..@ grid.index : int [1:5631] 1 2 3 4 5 6 7 8 9 10 ... ## ..@ coords : num [1:5631, 1:2] -10 -9.97 -9.95 -9.92 -9.9 ... ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : NULL ## .. .. ..$ : chr [1:2] &quot;s1&quot; &quot;s2&quot; ## ..@ bbox : num [1:2, 1:2] -10.01 42.24 -7.49 44.01 ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : chr [1:2] &quot;s1&quot; &quot;s2&quot; ## .. .. ..$ : chr [1:2] &quot;min&quot; &quot;max&quot; ## ..@ proj4string:Formal class &#39;CRS&#39; [package &quot;sp&quot;] with 1 slot ## .. .. ..@ projargs: chr &quot;+proj=longlat +datum=WGS84 +no_defs&quot; ## .. .. ..$ comment: chr &quot;GEOGCRS[\\&quot;unknown\\&quot;,\\n DATUM[\\&quot;World Geodetic System 1984\\&quot;,\\n ELLIPSOID[\\&quot;WGS 84\\&quot;,6378137,298.25722&quot;| __truncated__ plot(sppix, axes = TRUE) plot(galicia, add = TRUE) # NOTA: puede ser preferible asignar NA&#39;s a variables en SpatialGridDataFrame... object.size(spgrid) ## 4040 bytes object.size(sppix) ## 117680 bytes # Otras funciones: # as(sppix, &quot;SpatialGrid&quot;) recostruye la rejilla completa # gridded(ObjetoSpatialPoints) &lt;- TRUE convierte el objeto SpatialPoints en SpatialPixels "],["métodos-y-procedimientos-clases-sp.html", "A.2 Métodos y procedimientos clases sp", " A.2 Métodos y procedimientos clases sp Método Descripción [ selecciona elementos espaciales (puntos, líneas, polígonos, filas/columnas de una rejilla) y/o variables. $, [[ obtiene, establece o agrega variables (columnas). coordinates obtiene o establece (creando objetos sp) coordenadas. as(obj, clase) convierte un objeto a una clase. over, overlay combina objetos espaciales. spsample muestrea puntos dentro de una región (rectangular, polígono, línea o rejilla). A.2.1 Importar/exportar/transformar A través de R (paquetes que emplean sp) es fácil exportar datos a otras aplicaciones (e.g. Google Earth). Ejemplo importación: Datos descargados en formato NetCDF (Network Common Data Form) de NOAA Optimum Interpolated Sea Surface Temperature V2 (OISST) y procesados con NOAA_OISST_extraction_v2.R: load(&quot;datos/sstsp.RData&quot;) # SST 15-04-2012 jet.colors &lt;- colorRampPalette(c(&quot;#00007F&quot;, &quot;blue&quot;, &quot;#007FFF&quot;, &quot;cyan&quot;, &quot;#7FFF7F&quot;, &quot;yellow&quot;, &quot;#FF7F00&quot;, &quot;red&quot;, &quot;#7F0000&quot;)) image(sstsp, col = jet.colors(128), axes = TRUE) title(attr(sstsp@data, &quot;label&quot;)) # Ejemplo importar datos de otros paquetes: library(maps) library(maptools) world &lt;- map(&quot;world&quot;, fill = TRUE, plot = FALSE) # Hay un mapa con mayor resolución en mapdata::worldHires world_pol &lt;- map2SpatialPolygons(world, world$names, CRS(&quot;+proj=longlat +ellps=WGS84&quot;)) plot(world_pol, col = &#39;white&#39;, add = TRUE) "],["representaciones-gráficas.html", "A.3 Representaciones gráficas", " A.3 Representaciones gráficas A.3.1 Gráficos estándar plot(sdf, axes = TRUE, pch = 1) plot(galicia, add = TRUE) Color en función de una variable categórica: sdf$ano &lt;- factor(sdf$ano) # convertir año a factor colores &lt;- c(&quot;blue&quot;, &quot;yellow&quot;, &quot;red&quot;) color &lt;- colores[as.numeric(sdf$ano)] plot(sdf, axes = TRUE, col = color, pch = 19) legend(&quot;topleft&quot;, fill = colores, legend = levels(sdf$ano), bty = &quot;n&quot;) plot(galicia, add = TRUE) Usando p.e. la función classIntervals del paquete classInt se puede establecer los colores en función de una variable continua: library(classInt) # install.packages(&#39;classInt&#39;) class.int &lt;- classIntervals(sdf$lcpue, n = 5, style = &quot;quantile&quot;) pal &lt;- c(&quot;blue&quot;, &quot;red&quot;) # plot(class.int, pal = pal) class.col &lt;- findColours(class.int, pal = pal) plot(sdf, col = class.col, pch = 19) legend(&quot;topleft&quot;, fill = attr(class.col, &quot;palette&quot;), legend = names(attr(class.col, &quot;table&quot;)), bty = &quot;n&quot;) plot(galicia, add = TRUE) # methods(image) para rejillas # ver tambien splot, simage,... en library(npsp) A.3.2 Gráficos lattice: spplot Ventajas: Ideales para las clases sp (para gráfico automáticos) Inconveniente: los gráficos lattice requieren mayor tiempo de aprendizaje (dificultades para personalizarlos) library(lattice) spplot(sdf, &quot;lcpue&quot;, main = &quot;CPUE (escala logarítmica)&quot;, col.regions = topo.colors(6), cuts=5) bubble(sdf, &quot;cpue&quot;, main = &quot;CPUE&quot;) Añadir perfil de Galicia: sp.layout &lt;- list(&quot;sp.polygons&quot;, galicia) # Para añadir elementos se utiliza el parámetro sp.layout spplot(sdf, &quot;lcpue&quot;, main = &quot;CPUE (escala logarítmica)&quot;, col.regions = topo.colors(6), cuts = 5, sp.layout = sp.layout ) Alternativamente gráficos ggplot (ggplot2) con el paquete ggspatial "],["intro-geoR.html", "B Introducción al paquete geoR", " B Introducción al paquete geoR El paquete geoR proporciona herramientas para el análisis de datos geoestadísticos en R (otra alternativa es el paquete gstat, por ejemplo). A continuación se ilustran algunas de las capacidades de este paquete. "],["inicio-de-una-sesión-y-de-carga-de-datos.html", "B.1 Inicio de una sesión y de carga de datos", " B.1 Inicio de una sesión y de carga de datos Después de iniciar la sesión R, cargar geoR con el comando library (o require). Si el paquete se carga correctamente aparece un mensaje. library(geoR) ## -------------------------------------------------------------- ## Analysis of Geostatistical Data ## For an Introduction to geoR go to http://www.leg.ufpr.br/geoR ## geoR version 1.8-1 (built on 2020-02-08) is now loaded ## -------------------------------------------------------------- B.1.1 Archivos de datos Normalmente, los datos se almacenan como un objeto (una lista) de la clase geodata. Un objeto de esta clase contiene obligatoriamente dos elementos: $coords: las coordenadas de las posiciones de los datos. $data: los valores observados de la variables. Opcionalmente pueden tener otros elementos, como covariables y coordenadas de las fronteras de la zona de estudio. Hay algunos conjuntos de datos incluidos en el paquete de distribución. # data() # lista todos los conjuntos de datos disponibles # data(package = &quot;geoR&quot;) # lista los conjuntos de datos en el paquete geoR data(wolfcamp) # carga el archivo de datos wolfcamp summary(wolfcamp) ## Number of data points: 85 ## ## Coordinates summary ## Coord.X Coord.Y ## min -233.7217 -145.7884 ## max 181.5314 136.4061 ## ## Distance summary ## min max ## 0.3669819 436.2067085 ## ## Data summary ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 312.1095 471.8218 547.7156 610.2845 774.1778 1088.4209 Se pueden importar directamente un archivo de datos en formato texto: ncep &lt;- read.geodata(&#39;ncep.txt&#39;, header = FALSE, coords.col = 1:2, data.col = 4) # plot(ncep) # summary(ncep) También se puede convertir un data.frame a un objeto geodata: ncep.df &lt;- read.table(&#39;ncep.txt&#39;, header = FALSE) names(ncep.df) &lt;- c(&#39;x&#39;, &#39;y&#39;, &#39;t&#39;, &#39;z&#39;) # str(ncep.df) # Nota: los datos son espacio-temporales, pero geoR sólo admite datos 2D datgeo &lt;- as.geodata(ncep.df, coords.col = 1:2, data.col = 4) # plot(datgeo) # summary(datgeo) O objetos de datos espaciales (entre ellos los compatibles del paquete sp), por ejemplo el siguiente código crea un objeto SpatialPointsDataFrame y lo convierte a geodata: library(sp) load(&quot;caballa.galicia.RData&quot;) coordinates(caballa.galicia) &lt;- c(&quot;x&quot;,&quot;y&quot;) proj4string(caballa.galicia) &lt;- CRS(&quot;+proj=longlat +ellps=WGS84&quot;) datgeo &lt;- as.geodata(caballa.galicia[&quot;lcpue&quot;]) # Problemas con coordenadas duplicadas (ver ?duplicated) # plot(datgeo) # summary(datgeo) En la documentación de las funciones as.geodata y read.geodata hay más información sobre cómo importar/convertir datos. "],["análisis-descriptivo-de-datos-geoestadísticos.html", "B.2 Análisis descriptivo de datos geoestadísticos", " B.2 Análisis descriptivo de datos geoestadísticos Como se mostró anteriormente, el método summary proporciona un breve resumen descriptivo de los datos (ver ?summary.geodata). La función plot() genera por defecto gráficos de los valores en las posiciones espaciales (distinguiendo según cuartiles), los datos frente a las coordenadas y un histograma de los datos: plot(wolfcamp) Los gráficos de dispersión de los datos frente a las coordenadas nos pueden ayudar a determinar si hay una tendencia. También, en lugar del histograma, nos puede interesar un gráfico de dispersión 3D plot(wolfcamp, lowess = TRUE, scatter3d = TRUE) Si se asume que hay una tendencia puede interesar eliminarla: plot(wolfcamp, trend=~coords) El comando points(geodata) (función points.geodata) genera un gráfico con las posiciones de los datos (y por defecto con el tamaño de los puntos proporcional al valor): points(wolfcamp) Se pueden establecer los tamaños de los puntos, simbolos y colores a partir de los valores de los datos. Por ejemplo, para los puntos, empleando el argumento: pt.divide = c(\"data.proportional\", \"rank.proportional\", \"quintiles\", \"quartiles\", \"deciles\", \"equal\"). points(wolfcamp, col = &quot;gray&quot;, pt.divide = &quot;equal&quot;) "],["modelado-de-la-dependencia.html", "B.3 Modelado de la dependencia", " B.3 Modelado de la dependencia En la primera parte de esta sección consideraremos un proceso espacial sin tendencia: data(s100) # Cargar datos estacionarios summary(s100) ## Number of data points: 100 ## ## Coordinates summary ## Coord.X Coord.Y ## min 0.005638006 0.01091027 ## max 0.983920544 0.99124979 ## ## Distance summary ## min max ## 0.007640962 1.278175109 ## ## Data summary ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -1.1676955 0.2729882 1.1045936 0.9307179 1.6101707 2.8678969 ## ## Other elements in the geodata object ## [1] &quot;cov.model&quot; &quot;nugget&quot; &quot;cov.pars&quot; &quot;kappa&quot; &quot;lambda&quot; plot(s100) En el último apartado se tratará el caso general. B.3.1 Variogramas empíricos Los variogramas empíricos se calculan utilizando la función variog: oldpar &lt;- par(mfrow=c(1,2)) plot(variog(s100)) ## variog: computing omnidirectional variogram plot(variog(s100, max.dist = 0.6)) ## variog: computing omnidirectional variogram par(oldpar) La recomendación es considerar solo saltos hasta la mitad de la máxima distancia (ver Distance summary en resultados del sumario). vario &lt;- variog(s100, max.dist = 0.6) ## variog: computing omnidirectional variogram names(vario) ## [1] &quot;u&quot; &quot;v&quot; &quot;n&quot; &quot;sd&quot; ## [5] &quot;bins.lim&quot; &quot;ind.bin&quot; &quot;var.mark&quot; &quot;beta.ols&quot; ## [9] &quot;output.type&quot; &quot;max.dist&quot; &quot;estimator.type&quot; &quot;n.data&quot; ## [13] &quot;lambda&quot; &quot;trend&quot; &quot;pairs.min&quot; &quot;nugget.tolerance&quot; ## [17] &quot;direction&quot; &quot;tolerance&quot; &quot;uvec&quot; &quot;call&quot; # str(vario) NOTA: La componente u contiene los saltos, v las estimaciones del semivariograma (semivarianzas) y n el número de aportaciones. Los resultados pueden ser nubes de puntos (semivarianzas), valores discretizados (binned) o suavizados, dependiendo del parámetro: option = c(\"bin\", \"cloud\", \"smooth\") # Calculo de los variogramas empíricos vario.b &lt;- variog(s100, max.dist = 0.6) #discretizado ## variog: computing omnidirectional variogram vario.c &lt;- variog(s100, max.dist=0.6, op=&quot;cloud&quot;) #nube ## variog: computing omnidirectional variogram vario.bc &lt;- variog(s100, max.dist=0.6, bin.cloud=TRUE) #discretizado+nube ## variog: computing omnidirectional variogram vario.s &lt;- variog(s100, max.dist=0.6, op=&quot;sm&quot;, band=0.2) #suavizado ## variog: computing omnidirectional variogram # Representación gráfica oldpar&lt;-par(mfrow=c(2,2)) # Preparar para 4 gráficos por ventana plot(vario.b, main=&quot;Variograma empírico&quot;) plot(vario.c, main=&quot;Nube de puntos variograma&quot;) plot(vario.bc, bin.cloud=TRUE, main=&quot;Graficos de cajas&quot;) title(&quot;Gráficos de cajas&quot;) # Corregir fallo del comando anterior plot(vario.s, main=&quot;Variograma suavizado&quot;) par(oldpar) # Restaurar opciones de gráficos Si hay valores atípicos (o la distribución de los datos es asimétrica) puede ser preferible utilizar el estimador robusto. Se puede calcular este estimador estableciendo estimator.type = \"modulus\": varior.b &lt;- variog(s100, estimator.type = &quot;modulus&quot;, max.dist=0.6) ## variog: computing omnidirectional variogram varior.bc &lt;- variog(s100, estimator.type = &quot;modulus&quot;, max.dist=0.6, bin.cloud=TRUE) ## variog: computing omnidirectional variogram oldpar&lt;-par(mfrow=c(2,2)) #Preparar para 4 gráficos por ventana plot(vario.b, main=&quot;Estimador clásico&quot;) plot(varior.b, main=&quot;Estimador robusto&quot;) plot(vario.bc, bin.cloud=TRUE) plot(varior.bc, bin.cloud=TRUE) par(oldpar) #Restaurar opciones de gráficos En el caso de anisotropía, también se pueden obtener variogramas direccionales con la función variog mediante los argumentos direction y tolerance. Por ejemplo, para calcular un variograma en la dirección de 60 grados (con la tolerancia angular por defecto de 22.5 grados): vario.60 &lt;- variog(s100, max.dist = 0.6, direction = pi/3) #variograma en la dirección de 60 grados ## variog: computing variogram for direction = 60 degrees (1.047 radians) ## tolerance angle = 22.5 degrees (0.393 radians) Para estudiar si hay anisotropía, se pueden cálcular de forma rápida variogramas direccionales con la función variog4. Por defecto calcula cuatro variogramas direccionales, correspondientes a los ángulos 0, 45, 90 y 135 grados: vario.4 &lt;- variog4(s100, max.dist = 0.6) ## variog: computing variogram for direction = 0 degrees (0 radians) ## tolerance angle = 22.5 degrees (0.393 radians) ## variog: computing variogram for direction = 45 degrees (0.785 radians) ## tolerance angle = 22.5 degrees (0.393 radians) ## variog: computing variogram for direction = 90 degrees (1.571 radians) ## tolerance angle = 22.5 degrees (0.393 radians) ## variog: computing variogram for direction = 135 degrees (2.356 radians) ## tolerance angle = 22.5 degrees (0.393 radians) ## variog: computing omnidirectional variogram oldpar &lt;- par(mfrow=c(1,2)) plot(vario.60) title(main = expression(paste(&quot;direccional, angulo = &quot;, 60 * degree))) plot(vario.4, lwd = 2) par(oldpar) B.3.2 Ajuste de un modelo de variograma Los estimadores empíricos no pueden ser empleados en la práctica (no verifican necesariamente las propiedades de un variograma válido), por lo que se suele recurrir en la práctica al ajuste de un modelo válido. Con el paquete geoR podemos realizar el ajuste: A ojo: representando diferentes modelos sobre un variograma empírico (usando la función lines.variomodel o la función eyefit). Por mínimos cuadrados: ajustando por mínimos cuadrados ordinarios (OSL) o ponderados (WLS) al variograma empírico (usando la función variofit), Por máxima verosimilitud: estimando por máxima verosimilitud (ML) o máxima verosimilitud restringida (REML) los parámetros a partir de los datos (utilizando la función likfit), Métodos bayesianos (utilizando la función krige.bayes). Ejemplo de ajuste a ojo: vario.b &lt;- variog(s100, max.dist=0.6) #discretizado ## variog: computing omnidirectional variogram vario.s &lt;- variog(s100, max.dist=0.6,option = &quot;smooth&quot;, kernel = &quot;normal&quot;, band = 0.2) #suavizado ## variog: computing omnidirectional variogram plot(vario.b) lines(vario.s, type = &quot;l&quot;, lty = 2) lines.variomodel(cov.model = &quot;exp&quot;, cov.pars = c(1,0.3), nugget = 0, max.dist = 0.6, lwd = 3) legend(0.3, 0.3, c(&quot;empirico&quot;, &quot;suavizado&quot;, &quot;modelo exponencial&quot;), lty = c(1, 2, 1), lwd = c(1, 1, 3)) Otros ajustes: plot(vario.b) lines.variomodel(cov.model = &quot;exp&quot;, cov.pars = c(0.9,0.3), nug = 0.1, max.dist = 0.6) lines.variomodel(cov.model = &quot;mat&quot;, cov.pars = c(0.85,0.2), nug = 0.1, kappa = 1, max.dist = 0.6,lty = 2) lines.variomodel(cov.model = &quot;sph&quot;, cov.pars = c(0.8,0.8), nug = 0.1, max.dist = 0.6, lwd = 2) Nota: no hace falta escribir el nombre completo de los parámetros (basta con que no dé lugar a confusión). En las versiones recientes de geoR está disponible una función para realizar el ajuste gráficamente de forma interactiva (cuadro de diálogo en tcl/tk): eyefit(vario.b) Cuando se utilizan las funciones variofit y likfit para la estimación de parámetros, el efecto pepita (nugget) puede ser estimado o establecido a un valor fijo. Lo mismo ocurre con los parámetros de suavidad, anisotropía y transformación de los datos. También se dispone de opciones para incluir una tendencia. Las tendencias pueden ser polinomios en función de las coordenadas y/o funciones lineales de otras covariables. Ejemplos de estimación por mínimos cuadrados (llamadas a variofit): # Modelo exponencial con par ini umbral 1 y escala 0.5 (1/3 rango =1.5) vario.ols &lt;- variofit(vario.b, ini = c(1, 0.5), weights = &quot;equal&quot;) #ordinarios ## variofit: covariance model used is matern ## variofit: weights used: equal ## variofit: minimisation function used: optim vario.wls &lt;- variofit(vario.b, ini = c(1, 0.5), weights = &quot;cressie&quot;) #ponderados ## variofit: covariance model used is matern ## variofit: weights used: cressie ## variofit: minimisation function used: optim vario.wls ## variofit: model parameters estimated by WLS (weighted least squares): ## covariance model is: matern with fixed kappa = 0.5 (exponential) ## parameter estimates: ## tausq sigmasq phi ## 0.1955 2.0110 1.4811 ## Practical Range with cor=0.05 for asymptotic range: 4.437092 ## ## variofit: minimised weighted sum of squares = 31.5115 summary(vario.wls) ## $pmethod ## [1] &quot;WLS (weighted least squares)&quot; ## ## $cov.model ## [1] &quot;matern&quot; ## ## $spatial.component ## sigmasq phi ## 2.010972 1.481138 ## ## $spatial.component.extra ## kappa ## 0.5 ## ## $nugget.component ## tausq ## 0.1955322 ## ## $fix.nugget ## [1] FALSE ## ## $fix.kappa ## [1] TRUE ## ## $practicalRange ## [1] 4.437092 ## ## $sum.of.squares ## value ## 31.5115 ## ## $estimated.pars ## tausq sigmasq phi ## 0.1955322 2.0109718 1.4811376 ## ## $weights ## [1] &quot;cressie&quot; ## ## $call ## variofit(vario = vario.b, ini.cov.pars = c(1, 0.5), weights = &quot;cressie&quot;) ## ## attr(,&quot;class&quot;) ## [1] &quot;summary.variomodel&quot; Ejemplo de estimación por máxima verosimilitud (llamada a likfit): vario.ml &lt;- likfit(s100, ini = c(1, 0.5)) #Modelo exponencial con par ini umbral y escala (1/3 rango) ## --------------------------------------------------------------- ## likfit: likelihood maximisation using the function optim. ## likfit: Use control() to pass additional ## arguments for the maximisation function. ## For further details see documentation for optim. ## likfit: It is highly advisable to run this function several ## times with different initial values for the parameters. ## likfit: WARNING: This step can be time demanding! ## --------------------------------------------------------------- ## likfit: end of numerical maximisation. vario.ml ## likfit: estimated model parameters: ## beta tausq sigmasq phi ## &quot;0.7766&quot; &quot;0.0000&quot; &quot;0.7517&quot; &quot;0.1827&quot; ## Practical Range with cor=0.05 for asymptotic range: 0.547383 ## ## likfit: maximised log-likelihood = -83.57 summary(vario.ml) ## Summary of the parameter estimation ## ----------------------------------- ## Estimation method: maximum likelihood ## ## Parameters of the mean component (trend): ## beta ## 0.7766 ## ## Parameters of the spatial component: ## correlation function: exponential ## (estimated) variance parameter sigmasq (partial sill) = 0.7517 ## (estimated) cor. fct. parameter phi (range parameter) = 0.1827 ## anisotropy parameters: ## (fixed) anisotropy angle = 0 ( 0 degrees ) ## (fixed) anisotropy ratio = 1 ## ## Parameter of the error component: ## (estimated) nugget = 0 ## ## Transformation parameter: ## (fixed) Box-Cox parameter = 1 (no transformation) ## ## Practical Range with cor=0.05 for asymptotic range: 0.547383 ## ## Maximised Likelihood: ## log.L n.params AIC BIC ## &quot;-83.57&quot; &quot;4&quot; &quot;175.1&quot; &quot;185.6&quot; ## ## non spatial model: ## log.L n.params AIC BIC ## &quot;-125.8&quot; &quot;2&quot; &quot;255.6&quot; &quot;260.8&quot; ## ## Call: ## likfit(geodata = s100, ini.cov.pars = c(1, 0.5)) Ejemplo de estimación por máxima verosimilitud restringida (opción de likfit): vario.reml &lt;- likfit(s100, ini = c(1, 0.5), lik.method = &quot;RML&quot;) ## --------------------------------------------------------------- ## likfit: likelihood maximisation using the function optim. ## likfit: Use control() to pass additional ## arguments for the maximisation function. ## For further details see documentation for optim. ## likfit: It is highly advisable to run this function several ## times with different initial values for the parameters. ## likfit: WARNING: This step can be time demanding! ## --------------------------------------------------------------- ## likfit: end of numerical maximisation. summary(vario.reml) ## Summary of the parameter estimation ## ----------------------------------- ## Estimation method: restricted maximum likelihood ## ## Parameters of the mean component (trend): ## beta ## 0.7478 ## ## Parameters of the spatial component: ## correlation function: exponential ## (estimated) variance parameter sigmasq (partial sill) = 0.8473 ## (estimated) cor. fct. parameter phi (range parameter) = 0.2102 ## anisotropy parameters: ## (fixed) anisotropy angle = 0 ( 0 degrees ) ## (fixed) anisotropy ratio = 1 ## ## Parameter of the error component: ## (estimated) nugget = 0 ## ## Transformation parameter: ## (fixed) Box-Cox parameter = 1 (no transformation) ## ## Practical Range with cor=0.05 for asymptotic range: 0.6296295 ## ## Maximised Likelihood: ## log.L n.params AIC BIC ## &quot;-81.53&quot; &quot;4&quot; &quot;171.1&quot; &quot;181.5&quot; ## ## non spatial model: ## log.L n.params AIC BIC ## &quot;-125.1&quot; &quot;2&quot; &quot;254.1&quot; &quot;259.3&quot; ## ## Call: ## likfit(geodata = s100, ini.cov.pars = c(1, 0.5), lik.method = &quot;RML&quot;) NOTAS: Para fijar el nugget a un valor p.e. 0.15 añadir las opciones: fix.nugget = TRUE, nugget = 0.15. Se puede tener en cuenta anisotropía geométrica en los modelos de variograma a partir de los parámetros psiA (ángulo, en radianes, de la dirección de mayor dependencia espacial i.e. con el máximo rango) y psiR (relación, mayor o igual que 1, entre los rangos máximo y mínimo). Se pueden fijar a distintos valores o estimarlos incluyendo las opciones fix.psiA = FALSE y fix.psiR = FALSE en las llamadas a las rutinas de ajuste.) Representación gráfica junto al estimador empírico: plot(vario.b, main = &quot;Estimador empírico y modelos ajustados&quot;) lines(vario.ml, max.dist = 0.6) lines(vario.reml, lwd = 2, max.dist = 0.6) lines(vario.ols, lty = 2, max.dist = 0.6) lines(vario.wls, lty = 2, lwd = 2, max.dist = 0.6) legend(0.3, 0.3, legend = c(&quot;ML&quot;, &quot;REML&quot;, &quot;OLS&quot;, &quot;WLS&quot;), lty = c(1, 1, 2, 2), lwd = c(1, 2,1, 2)) B.3.3 Inferencia sobre el variograma Se pueden obtener dos tipos de envolventes (envelopes, i.e. valores máximos y mínimos aproximados) del variograma empírico mediante simulación: Bajo la hipótesis de que no hay correlación espacial (obtenidos por permutaciones aleatorias de los datos sobre las posiciones espaciales), para estudiar si hay una dependencia espacial significativa. Bajo un modelo de variograma, para ilustrar la variabilidad del variograma empírico. env.indep &lt;- variog.mc.env(s100, obj.var = vario.b) ## variog.env: generating 99 simulations by permutating data values ## variog.env: computing the empirical variogram for the 99 simulations ## variog.env: computing the envelops env.model &lt;- variog.model.env(s100, obj.var = vario.b, model = vario.wls) ## variog.env: generating 99 simulations (with 100 points each) using the function grf ## variog.env: adding the mean or trend ## variog.env: computing the empirical variogram for the 99 simulations ## variog.env: computing the envelops oldpar &lt;- par(mfrow = c(1, 2)) plot(vario.b, envelope = env.indep) plot(vario.b, envelope = env.model) lines(vario.wls, lty = 2, lwd = 2, max.dist = 0.6) par(oldpar) Para estudiar si hay una dependencia espacial significativa se puede emplear también la rutina sm.variogram del paquete sm. Estableciendo model = \"independent\" devuelve un p-valor para contrastar la hipótesis nula de independencia (i.e. se acepta que hay una dependencia espacial si \\(p \\leq \\alpha = 0.05\\)) y un gráfico en el que se muestra el estimador empírico robusto, un estimador suavizado y una región de confianza para el variograma suponiendo que el proceso es independiente (i.e. consideraríamos que hay dependencia espacial si el variograma suavizado no está contenido en esa región). library(sm) ## Package &#39;sm&#39;, version 2.2-5.6: type help(sm) for summary information sm.variogram(s100$coords, s100$data, model = &quot;independent&quot;) ## Test of spatial independence: p = 0.024 Nota: Se puede realizar contrastes adicionales estableciendo el parámetro model a \"isotropic\" o \"stationary\". B.3.4 Estimación del variograma en procesos no estacionarios Cuando el proceso no es estacionario (no se puede emplear directamente los estimadores empíricos) hay que eliminar la tendencia para estimar el variograma: oldpar &lt;- par(mfrow=c(1,2)) plot(variog(wolfcamp, max.dist = 200)) # Supone que el proceso es estacionario ## variog: computing omnidirectional variogram plot(variog(wolfcamp, trend = ~coords, max.dist = 200)) # Asume una tendencia lineal en las coordenadas ## variog: computing omnidirectional variogram par(oldpar) "],["predicción-espacial-kriging.html", "B.4 Predicción espacial (kriging)", " B.4 Predicción espacial (kriging) El paquete geoR dispone de opciones para los métodos kriging tradicionales, que dependiendo de las suposiciones acerca de la función de tendencia se clasifican en: Kriging simple (KS): media conocida Kriging ordinario (KO): se supone que la media es constante y desconocida. Kriging universal (KU): también denominado kriging con modelo de tendencia, se supone que la media es una combinación lineal (desconocida) de las coordenadas o de otras variables explicativas. Existen también opciones adicionales para kriging trans-normal (con transformaciones Box-Cox para aproximarse a la normalidad y transformación de nuevo de resultados a la escala original manteniendo insesgadez). También admite modelos de variograma geométricamente anisotrópicos. Para obtener una rejilla discreta de predicción puede ser de utilidad la función expand.grid: # Rejilla regular 51x51 en cuadrado unidad xx &lt;- seq(0, 1, l = 51) yy &lt;- seq(0, 1, l = 51) pred.grid &lt;- expand.grid(x = xx, y = yy) plot(s100$coords, pch = 20, asp = 1) points(pred.grid, pch = 3, cex = 0.2) El comando para realizar kriging ordinario con variograma vario.wls sería: ko.wls &lt;- krige.conv(s100, loc = pred.grid, krige = krige.control(obj.m = vario.wls)) ## krige.conv: model with constant mean ## krige.conv: Kriging performed using global neighbourhood El resultado es una lista incluyendo predicciones (ko.wls$predict) y varianzas kriging (ko.wls$krige.var): names(ko.wls) ## [1] &quot;predict&quot; &quot;krige.var&quot; &quot;beta.est&quot; &quot;distribution&quot; &quot;message&quot; ## [6] &quot;call&quot; Para ver todas las opciones de kriging disponibles ejecutar ?krige.control. Para kriging con vecindario local (archivos de datos grandes) se puede utilizar la función ksline. Para representar las superficies se podría utilizar la función image(), aunque la última versión del método image.kriging() puede fallar al añadir elementos (por lo menos en RMarkdown; tampoco es compatible con par(mfrow)): # oldpar &lt;- par(mfrow = c(1, 2)) # image.kriging no es compatible con mfrow en últimas versiones image(ko.wls, coords.data=s100$coords, main = &quot;Superficie de predicciones&quot;) contour(ko.wls, add = TRUE) #añadir gráfico de contorno image(ko.wls, coords.data=s100$coords, values = sqrt(ko.wls$krige.var), main = &quot;Superficie de err. std. kriging&quot;) contour(ko.wls, values = sqrt(ko.wls$krige.var), add = TRUE) # par(oldpar) Otras opciones: contour(ko.wls,filled = TRUE) fcol &lt;- topo.colors(10)[cut(matrix(ko.wls$pred,nrow=51,ncol=51)[-1,-1],10,include.lowest=TRUE)] persp(ko.wls, theta=-60, phi=40, col=fcol) if(!require(plot3D)) stop(&#39;Required pakage `plot3D` not installed.&#39;) # install.packages(&#39;plot3D&#39;) ## Loading required package: plot3D persp3D(xx, yy, matrix(ko.wls$predict, nrow = length(xx)), theta=-60, phi=40) if(!require(npsp)) { cat(&quot;Required pakage `npsp` not installed!\\n&quot;) cat(&quot;On windows, run `install.packages(&#39;https://github.com/rubenfcasal/npsp/releases/download/v0.7-8/npsp_0.7-8.zip&#39;, repos = NULL)`\\n&quot;) } else spersp(xx, yy, ko.wls$predict, theta=-60, phi=40) ## Loading required package: npsp ## Package npsp: Nonparametric Spatial Statistics, ## version 0.7-8 (built on 2021-05-10). ## Copyright (C) R. Fernandez-Casal 2012-2021. ## Type `help(npsp)` for an overview of the package or ## visit https://rubenfcasal.github.io/npsp. ## ## Attaching package: &#39;npsp&#39; ## The following object is masked from &#39;package:sm&#39;: ## ## binning B.4.1 Validación cruzada Para verificar si un modelo (de tendencia y variograma) describe adecuadamente la variabilidad espacial de los datos (p.e. para comparar modelos), se emplea normalmente la técnica de validación cruzada, función xvalid en geoR. Por defecto la validación se realiza sobre los datos eliminando cada observación (y utilizando las restantes para predecir), aunque se puede utilizar un conjunto diferente de posiciones (o de datos) mediante el argumento location.xvalid (y data.xvalid). En el caso de procesos estacionarios permitiría diagnosticar si el modelo de variograma describe adecuadamente la dependencia espacial de los datos: xv.wls &lt;- xvalid(s100, model = vario.wls) ## xvalid: number of data locations = 100 ## xvalid: number of validation locations = 100 ## xvalid: performing cross-validation at location ... 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, ## xvalid: end of cross-validation summary(xv.wls) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## errors -1.429944 -0.4017821 0.04881742 0.0008450629 0.3359677 1.319640 ## std.errors -2.110654 -0.7048560 0.07804159 0.0011568059 0.5922810 2.228054 ## sd ## errors 0.5299818 ## std.errors 0.9190753 xv.reml &lt;- xvalid(s100, model = vario.reml) ## xvalid: number of data locations = 100 ## xvalid: number of validation locations = 100 ## xvalid: performing cross-validation at location ... 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, ## xvalid: end of cross-validation summary(xv.reml) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## errors -1.178020 -0.3109277 0.02326020 0.011894019 0.2631596 1.521489 ## std.errors -2.419106 -0.7304294 0.07954355 0.009241635 0.5802049 2.690047 ## sd ## errors 0.4813133 ## std.errors 0.9906166 Por defecto la función plot (plot.xvalid) muestra 10 gráficos diferentes (para más información ejecutar ?plot.xvalid), a grosso modo los cinco primeros se corresponden con residuos simples (valores observados menos predicciones) y los siguientes con residuos estandarizados (dividiendo por la raíz cuadrada de la varianza de predicción). oldpar &lt;- par(mfrow = c(2, 5), mar = c(bottom = 4.5, left = 4, top = 2, right = 2)) plot(xv.wls, ask = FALSE) par(oldpar) # plot(xv.reml) NOTA: Para re-estimar los parámetros del modelo cada vez que se elimina una observación (i.e. validar el procedimiento de estimación) añadir la opción reest = TRUE (puede requerir mucho tiempo de computación). "],["referencias.html", "Referencias", " Referencias Bibliografía básica Bivand, R.S., Pebesma, E.J. y Gómez-Rubio, V. (2008). Applied Spatial Data Analysis with R. Springer. Diggle, P. y Ribeiro, P.J. (2007). Model-based Geostatistics. Springer. Schabenberger, O. y Gotway, C.A. (2005). Statistical Methods for Spatial Data Analysis. Chapman and Hall. Bibliografía complementaria Chilès, J.P. y P. Delfiner (2012). Geostatistics: modeling spatial uncertanity. Wiley. Cressie, N. (1993). Statistics for Spatial Data. John Wiley. Wikle, C.K., Zammit-Mangion, A. y Cressie, N. (2019). Spatio-temporal Statistics with R. Chapman and Hall/CRC (accesible online). "],["bibliografía-completa.html", "Bibliografía completa", " Bibliografía completa Bivand, R. S., Pebesma, E., y Gómez-Rubio, V. (2013). Applied Spatial Data Analysis with R (Second). Springer. http://www.asdar-book.org/ Pebesma, E. (2018). Simple Features for R: Standardized Support for Spatial Vector Data. The R Journal, 10(1), 439-446. https://doi.org/10.32614/RJ-2018-009 Pebesma, E., y Bivand, R. (2021). Spatial Data Science. https://keen-swartz-3146c4.netlify.app Pebesma, E. J., y Bivand, R. S. (2005). Classes and methods for spatial data in R. R News, 5(2), 9-13. https://CRAN.R-project.org/doc/Rnews/ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
